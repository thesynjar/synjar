# Security Review Report - 2025-12-25

**Reviewer:** Security Review Agent
**Date:** 2025-12-25 12:00
**Scope:** SPEC-001 Row Level Security (RLS) Implementation
**Status:** Implementation Complete - 26/26 Tests Passing

---

## Kontekst

### Przeanalizowane moduły
- `apps/api/src/infrastructure/persistence/prisma/prisma.service.ts` - RLS context management
- `apps/api/src/infrastructure/persistence/rls/` - RLS middleware, UserContext, bypass service
- `apps/api/prisma/migrations/20251225*` - 10 RLS migrations (initial setup through final fixes)
- `apps/api/src/application/workspace/workspace.service.ts` - RLS usage in application layer
- `apps/api/prisma/schema.prisma` - Added `createdById` to Workspace for RLS INSERT policy

### Powiązane dokumenty
- `docs/specifications/SPEC-001-row-level-security.md` - RLS specification (COMPLETED)
- `docs/specifications/2025-12-24-knowledge-forge.md` - Overall system architecture
- `CLAUDE.md` - Project guidelines

### Implementation Summary
The RLS implementation follows PostgreSQL Row Level Security best practices:
1. Database-level isolation using `app.current_user_id` session variable
2. Non-superuser database role (`knowledge_forge_app`) enforces RLS
3. Transaction-scoped context via `set_config(..., true)`
4. Separate policies per operation (SELECT, INSERT, UPDATE, DELETE)
5. SYSTEM bypass mode for migrations/public API
6. Comprehensive test coverage (26/26 tests passing)

---

## CRITICAL (wymaga natychmiastowej naprawy)

**BRAK KRYTYCZNYCH PODATNOŚCI**

---

## HIGH (naprawić przed merge)

### 1. [SQL Injection] Raw SQL with $executeRawUnsafe in integration tests

**Lokalizacja:**
- `apps/api/src/infrastructure/persistence/rls/__tests__/rls.integration.spec.ts:315-323`

**Problem:**
```typescript
await prismaSuperuser.$executeRawUnsafe(`
  INSERT INTO "Chunk" (id, "documentId", content, embedding, "chunkIndex", "createdAt")
  VALUES ($1, $2, 'Chunk content A', $3::vector, 0, NOW())
`, chunkAId, documentA.id, embeddingA);
```

Use `$executeRaw` with tagged template instead of `$executeRawUnsafe` to prevent SQL injection.

**Jak naprawić:**
```typescript
await prismaSuperuser.$executeRaw`
  INSERT INTO "Chunk" (id, "documentId", content, embedding, "chunkIndex", "createdAt")
  VALUES (${chunkAId}, ${documentA.id}, 'Chunk content A', ${embeddingA}::vector, 0, NOW())
`;
```

**Risk:** MEDIUM (only in tests, not production code, but sets bad precedent)

---

### 2. [SQL Injection] Raw SQL in document processor

**Lokalizacja:**
- `apps/api/src/application/document/document.service.ts:313-325`
- `apps/api/src/application/document/document-processor.service.ts:113-125`

**Problem:**
Uses `$executeRaw` for chunk insertion. Code review shows it uses Prisma's tagged templates correctly, which is SAFE. However, verify no string interpolation is used.

**Verification needed:**
```typescript
await this.prisma.$executeRaw`
  INSERT INTO "Chunk" (id, "documentId", content, embedding, "chunkIndex", "chunkType", metadata, "createdAt")
  VALUES (
    gen_random_uuid(),
    ${documentId},
    ${chunk.content},
    ${JSON.stringify(embedding)}::vector,
    ${i},
    ${chunk.chunkType || null},
    ${chunk.metadata ? JSON.stringify(chunk.metadata) : null}::jsonb,
    NOW()
  )
`;
```

**Status:** SAFE (uses tagged templates, not string concatenation)

---

### 3. [Broken Access] SYSTEM bypass mode too permissive

**Lokalizacja:**
- `apps/api/src/infrastructure/persistence/prisma/prisma.service.ts:115-123`
- `apps/api/prisma/migrations/20251225104500_add_system_bypass/migration.sql:29-32`

**Problem:**
The `withoutRls()` method sets `app.current_user_id = 'SYSTEM'` which bypasses ALL RLS policies. The function checks for `'SYSTEM'` in SQL:

```sql
IF user_id_text = 'SYSTEM' THEN
  RETURN QUERY SELECT id FROM "Workspace";
  RETURN;
END IF;
```

**Risk:** HIGH - if `withoutRls()` is misused in application code, it could expose data across tenants.

**Current usage audit:**
```bash
grep -r "withoutRls" apps/api/src --include="*.ts"
```

**Findings:**
- Used in `PrismaSystemService` (migrations/tests) - SAFE
- Documentation warns "USE WITH EXTREME CAUTION" - GOOD
- No usage found in application layer outside tests - GOOD

**Recommendation:**
1. Add runtime check to ensure `withoutRls()` is only called from specific modules (Public API, migrations)
2. Consider separate database role for public API instead of SYSTEM bypass
3. Add audit logging when SYSTEM bypass is used

**Jak naprawić:**
```typescript
async withoutRls<T>(
  callback: (tx: TransactionClient) => Promise<T>,
  reason?: 'PUBLIC_API' | 'MIGRATION' | 'ADMIN',
): Promise<T> {
  // Log bypass usage
  this.logger.warn(`RLS bypass requested: ${reason || 'UNKNOWN'}`);

  // In production, restrict to specific call sites
  if (process.env.NODE_ENV === 'production' && !reason) {
    throw new Error('RLS bypass requires explicit reason in production');
  }

  return this.$transaction(async (tx) => {
    await tx.$executeRaw`SELECT set_config('app.current_user_id', 'SYSTEM', true)`;
    return callback(tx);
  });
}
```

---

## MEDIUM (naprawić w kolejnej iteracji)

### 1. [Sensitive Data] Database credentials in .env

**Lokalizacja:**
- `apps/api/.env` (file permissions: `-rw-------` - GOOD)
- `.env.example` uses generic credentials - GOOD

**Problem:**
The `.env` file contains database password `knowledge_forge_app_password` which appears to be a weak/default password.

**Recommendation:**
1. Use strong, randomly generated passwords in production
2. Rotate credentials after deployment
3. Consider using managed secrets (AWS Secrets Manager, HashiCorp Vault)
4. Document credential rotation policy

**Jak naprawić:**
```bash
# Generate strong password
openssl rand -base64 32

# Update DATABASE_URL
DATABASE_URL="postgresql://knowledge_forge_app:$(openssl rand -base64 32)@localhost:6201/knowledge_forge"
```

---

### 2. [Security Misconfiguration] JWT secret in .env.example

**Lokalizacja:**
- `apps/api/.env.example:5`

**Problem:**
```
JWT_SECRET="your-super-secret-jwt-key-change-in-production"
```

The example uses a generic secret. While this is just an example file, developers might forget to change it.

**Recommendation:**
1. Add validation at startup to reject default JWT_SECRET in production
2. Generate random secret on first run if not set
3. Add comment with generation command

**Jak naprawić:**
```typescript
// In main.ts or config validation
if (process.env.NODE_ENV === 'production') {
  const dangerousDefaults = [
    'your-super-secret-jwt-key-change-in-production',
    'change-me',
    'secret',
  ];

  if (dangerousDefaults.includes(process.env.JWT_SECRET || '')) {
    throw new Error('SECURITY: Using default JWT_SECRET in production is forbidden');
  }
}
```

---

### 3. [Information Disclosure] Error messages in RLS

**Lokalizacja:**
- `apps/api/src/infrastructure/persistence/rls/user.context.ts:37-40`

**Problem:**
```typescript
throw new Error(
  'User context not set. Ensure RlsMiddleware is properly configured.',
);
```

This error reveals internal implementation details. In production, attackers could use this to identify RLS bypass opportunities.

**Recommendation:**
Log detailed error server-side, return generic message to client.

**Jak naprawić:**
```typescript
getCurrentUserId(): string {
  const store = this.storage.getStore();

  if (!store?.userId) {
    this.logger.error('User context not set - RlsMiddleware may not be configured');
    throw new UnauthorizedException('Authentication required');
  }

  return store.userId;
}
```

---

### 4. [Insecure Design] No rate limiting on RLS bypass

**Lokalizacja:**
- Public API endpoints using `withoutRls()`

**Problem:**
Public API bypasses RLS without apparent rate limiting. An attacker with a valid public token could enumerate all workspace data.

**Recommendation:**
1. Implement rate limiting for public API endpoints
2. Add token usage tracking
3. Set expiration on public tokens
4. Add IP-based throttling

**Jak naprawić:**
Already implemented in `@nestjs/throttler` (line 36 in package.json), verify configuration:

```typescript
// In AppModule
ThrottlerModule.forRoot({
  ttl: 60,
  limit: 10, // 10 requests per minute for public API
}),

// In PublicController
@UseGuards(ThrottlerGuard)
@Throttle(5, 60) // More restrictive for public
export class PublicController {
  // ...
}
```

---

### 5. [Missing Security Headers] CORS configuration

**Lokalizacja:**
- `apps/api/src/main.ts` - CORS configuration

**Current implementation:**
```typescript
app.enableCors({
  origin: process.env.CORS_ORIGINS?.split(',') || [
    'http://localhost:3000',
    'http://localhost:5173',
  ],
  credentials: true,
});
```

**Recommendation:**
Add additional security headers:
```typescript
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
}));
```

---

## LOW (rekomendacja)

### 1. [Code Quality] Missing input validation on userId in forUser()

**Lokalizacja:**
- `apps/api/src/infrastructure/persistence/prisma/prisma.service.ts:48-58`

**Problem:**
No validation that `userId` is a valid UUID before setting in database session.

**Recommendation:**
```typescript
async forUser<T>(
  userId: string,
  callback: (tx: TransactionClient) => Promise<T>,
): Promise<T> {
  // Validate UUID format to prevent SQL injection attempts
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(userId)) {
    throw new Error('Invalid user ID format');
  }

  return this.$transaction(async (tx) => {
    await tx.$executeRaw`SELECT set_config('app.current_user_id', ${userId}::text, true)`;
    return callback(tx);
  });
}
```

---

### 2. [Logging & Monitoring] No audit trail for RLS bypasses

**Lokalizация:**
- `apps/api/src/infrastructure/persistence/prisma/prisma.service.ts:115-123`

**Problem:**
When `withoutRls()` is called, there's no audit log. This makes it impossible to track who bypassed RLS and when.

**Recommendation:**
```typescript
async withoutRls<T>(
  callback: (tx: TransactionClient) => Promise<T>,
): Promise<T> {
  // Audit log
  this.logger.warn({
    event: 'RLS_BYPASS',
    timestamp: new Date().toISOString(),
    stackTrace: new Error().stack,
  });

  return this.$transaction(async (tx) => {
    await tx.$executeRaw`SELECT set_config('app.current_user_id', 'SYSTEM', true)`;
    return callback(tx);
  });
}
```

---

### 3. [Dependencies] Vulnerable components check

**Status:** Could not verify due to pnpm lockfile issue

**Recommendation:**
```bash
cd apps/api
pnpm audit
pnpm audit --fix
```

Check for known vulnerabilities in:
- `openai` (^4.77.0)
- `@aws-sdk/client-s3` (^3.712.0)
- `passport-jwt` (^4.0.1)
- `bcrypt` (^5.1.1)

---

### 4. [Code Quality] Magic string 'SYSTEM' hardcoded

**Lokalizacja:**
- Multiple locations use hardcoded `'SYSTEM'` string

**Recommendation:**
Create constant:
```typescript
// apps/api/src/infrastructure/persistence/rls/rls.constants.ts
export const RLS_BYPASS_CONTEXT = 'SYSTEM' as const;

// Usage
await tx.$executeRaw`SELECT set_config('app.current_user_id', ${RLS_BYPASS_CONTEXT}, true)`;
```

---

### 5. [Testing] Missing negative test cases

**Lokalizacja:**
- `apps/api/src/infrastructure/persistence/rls/__tests__/rls.integration.spec.ts`

**Good coverage (26 tests)**, but missing:
1. Test for SQL injection attempts via userId
2. Test for race conditions in AsyncLocalStorage
3. Test for RLS enforcement when middleware fails
4. Test for TOCTTOU attacks (time-of-check-time-of-use)

**Recommendation:**
```typescript
it('should reject SQL injection attempts in userId', async () => {
  const maliciousUserId = "'; DROP TABLE Workspace; --";

  await expect(
    prisma.forUser(maliciousUserId, async (tx) => {
      return tx.workspace.findMany();
    })
  ).rejects.toThrow('Invalid user ID format');
});

it('should maintain isolation during concurrent requests', async () => {
  // Test AsyncLocalStorage isolation
  const results = await Promise.all([
    prisma.forUser(userA.id, tx => tx.workspace.findMany()),
    prisma.forUser(userB.id, tx => tx.workspace.findMany()),
  ]);

  expect(results[0]).toHaveLength(1);
  expect(results[0][0].id).toBe(workspaceA.id);
  expect(results[1]).toHaveLength(1);
  expect(results[1][0].id).toBe(workspaceB.id);
});
```

---

## Pozytywne aspekty

### 1. Excellent RLS Architecture
- Follows PostgreSQL best practices (SECURITY DEFINER functions, transaction-scoped settings)
- Separate policies per operation (SELECT, INSERT, UPDATE, DELETE)
- Uses `FORCE ROW LEVEL SECURITY` to prevent superuser bypass
- Non-superuser database role enforces RLS in production-like environment

### 2. Comprehensive Test Coverage
- 26/26 tests passing
- Tests cover all critical scenarios: isolation, ID manipulation, concurrent access
- Real database integration tests (not mocks)
- Stress tests with 50+ parallel operations

### 3. SQL Injection Protection
- Uses Prisma's parameterized queries (`$executeRaw` with tagged templates)
- No string concatenation in SQL queries in production code
- Only `$executeRawUnsafe` found in test files (acceptable)

### 4. Clean Architecture
- Separation of concerns: PrismaService handles RLS context, middleware sets user
- AsyncLocalStorage ensures proper request isolation
- Transaction-scoped context prevents cross-request contamination

### 5. Security Defense in Depth
- Database-level RLS as second layer after application authorization
- `createdById` column enables proper INSERT policy enforcement
- SYSTEM bypass is documented and limited in scope

### 6. Production-Ready Configuration
- Non-superuser database user (`knowledge_forge_app`)
- File permissions on `.env` are restrictive (`-rw-------`)
- Separate DATABASE_URL for migrations (superuser) vs runtime (RLS user)

### 7. Proper Credential Management
- JWT tokens in HTTP-only cookies
- `secure` flag based on NODE_ENV
- Credentials not hardcoded in source

### 8. Good Documentation
- SPEC-001 is comprehensive and accurate
- Code comments explain RLS context management
- Examples provided in JSDoc

---

## Podsumowanie i Rekomendacje Priorytetowe

### Pilne (przed production)
1. Dodać walidację UUID w `forUser()` (LOW → przenoszę do HIGH dla produkcji)
2. Dodać audit logging dla `withoutRls()`
3. Zaimplementować rate limiting dla Public API
4. Sprawdzić i naprawić podatności w dependencies (`pnpm audit`)

### Średni priorytet
1. Ulepszyć error messages (nie ujawniać szczegółów implementacji)
2. Dodać runtime checks dla JWT_SECRET w production
3. Rozważyć separate database role dla Public API zamiast SYSTEM bypass
4. Dodać testy dla SQL injection attempts

### Niska priorytet
1. Wyodrębnić magic string 'SYSTEM' do stałej
2. Dodać helmet.js dla security headers
3. Rozszerzyć test coverage o edge cases

---

## Ostateczna Ocena

**SECURITY SCORE: 8.5/10**

**Uzasadnienie:**
- Implementacja RLS jest solidna i zgodna z best practices
- Brak krytycznych podatności
- Comprehensive test coverage
- Kilka obszarów do poprawy (głównie defense in depth)
- Gotowe do merge po naprawieniu HIGH findings

**RECOMMENDATION: APPROVE with conditions**

Warunki przed merge:
1. Fix HIGH #3: Add audit logging and runtime checks for `withoutRls()`
2. Run `pnpm audit` and address any HIGH/CRITICAL vulnerabilities
3. Add UUID validation in `forUser()`

**RECOMMENDATION: Proceed to production after:**
1. All HIGH findings addressed
2. Dependencies audit clean
3. Code review approved by senior developer
4. Penetration testing on RLS isolation (optional but recommended)

---

**Signature:** Security Review Agent
**Date:** 2025-12-25
**Review Version:** 1.0
