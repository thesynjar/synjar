# Documentation Review Report - 2025-12-25

## Context

- **Specyfikacja:** SPEC-001-row-level-security.md
- **Status specyfikacji:** Draft (should be COMPLETED)
- **Produkty dotknięte:** apps/api (backend core)
- **ADR sprawdzone:** Brak katalogu ADR (powinien istnieć)
- **Migrations applied:** 10 migrations (20251225102653 through 20251225140000)
- **Test coverage:** 26/26 RLS integration tests PASSING
- **Current TODO status:** [~] (in progress - should be [x])

## Specyfikacja - Status Realizacji

### Status: Fully Implemented with Minor Deviations

**Implementation Notes (Section 9) w specyfikacji:**
- Specyfikacja została zaktualizowana z pełnymi implementation notes (sekcja 9)
- Status oznaczony jako "FULLY IMPLEMENTED"
- Dokumentacja zawiera rzeczywisty przebieg implementacji (10 migracji zamiast 1)
- Test results udokumentowane: 26/26 PASSING

**Odchylenia od pierwotnej specyfikacji:**
1. Zamiast jednej migracji SQL - 10 iteracyjnych migracji (uzasadnione - chicken-and-egg problem)
2. Dodano kolumnę `createdById` do Workspace (niezbędne dla INSERT policy)
3. `RlsBypassService` zaimplementowany jako `withoutRls()` w PrismaService (uproszczenie architektury)
4. Dodano `UserContext` z AsyncLocalStorage (lepsza izolacja kontekstu per request)
5. Dodano `PrismaSystemService` dla operacji superuser (migracje/testy)

**Definition of Done (Sekcja 7):**
- [x] Migracja SQL - DONE (10 migracji zamiast 1)
- [x] RLS Middleware - DONE
- [x] PrismaService wrappers - DONE (`forUser()`, `withCurrentUser()`, `withoutRls()`)
- [x] Public API bypass - DONE
- [x] Testy integracyjne - DONE (26/26 PASSING)
- [x] Non-superuser database user - DONE (`knowledge_forge_app`)
- [ ] Performance tests - NOT DONE
- [ ] Documentation in README - NOT DONE

## Critical Issues (dokumentacja wprowadza w błąd)

### 1. Brak ecosystem.md - Krityczna luka w dokumentacji architektury

**Problem:**
- docs/README.md odwołuje się do `docs/ecosystem.md` jako "mapa systemu"
- Ten plik NIE ISTNIEJE
- Zgodnie z rolą Documentation Reviewer: "ecosystem.md MUSI być aktualny - to mapa systemu"

**Impact:**
- Nowi developerzy nie wiedzą jak system jest zorganizowany
- Brak definicji Bounded Contexts
- Brak mapy Event Bus przepływów
- Brak definicji Source of Truth per encja

**Jak naprawić:**
```markdown
# docs/ecosystem.md

## Platform Layer + Business Layer

Knowledge Forge używa Clean Architecture z następującymi warstwami:

### Domain Layer (Business Logic)
- Entities: User, Workspace, Document, Chunk
- Value Objects: Email, Token, Embedding
- Domain Services: DocumentProcessingService

### Application Layer (Use Cases)
- WorkspaceService - zarządzanie workspace'ami
- DocumentService - CRUD dokumentów
- AuthService - autentykacja użytkowników
- SearchService - semantic search (RAG)

### Infrastructure Layer (Adapters)
- PrismaService - PostgreSQL persistence
- EmbeddingsService - OpenAI embeddings
- StorageService - Backblaze B2
- RLS - Row Level Security enforcement

### Interface Layer (Controllers)
- REST API: /api/v1/*
- Swagger docs: /api/docs

## Bounded Contexts

| Context | Entities | Responsibilities |
|---------|----------|------------------|
| Auth | User | Registration, login, JWT |
| Workspace | Workspace, WorkspaceMember | Multi-tenancy, access control |
| Documents | Document, Tag, DocumentTag | Knowledge base CRUD |
| Embeddings | Chunk | Vector storage, semantic search |
| Public API | PublicLink | Token-based public access |

## Event Bus (EventEmitter2)

### Published Events
- `workspace.member.added` → TenantLookupListener
- `workspace.member.removed` → TenantLookupListener
- `user.email.changed` → TenantLookupListener

### Future Events
- `document.created`
- `document.updated`
- `document.deleted`
- `chunk.processed`

## Module API (Internal Queries)

Moduły komunikują się przez DI, nie przez HTTP:

```typescript
// WorkspaceService → DocumentService
async getDocuments(workspaceId: string): Promise<Document[]>

// AuthService → WorkspaceService
async getUserWorkspaces(userId: string): Promise<Workspace[]>

// DocumentService → SearchService
async search(workspaceId: string, query: string): Promise<SearchResult[]>
```

## Source of Truth

| Encja | Source | Read Path |
|-------|--------|-----------|
| User | PostgreSQL (User) | Direct |
| Workspace | PostgreSQL (Workspace) | RLS filtered |
| Document | PostgreSQL (Document) | RLS filtered |
| Chunk | PostgreSQL (Chunk) | RLS filtered |
| File Content | Backblaze B2 | Document.fileUrl |
| Embeddings | PostgreSQL (Chunk.embedding) | pgvector |

## Security Architecture (RLS)

### RLS Policies Per Table
- Workspace: workspace_select, workspace_insert, workspace_update, workspace_delete
- Document: document_isolation (FOR ALL)
- Chunk: chunk_isolation (przez document)
- WorkspaceMember: member_isolation (FOR ALL)
- PublicLink: public_link_isolation (FOR ALL)

### User Context Flow
```
Request → JwtAuthGuard → RlsMiddleware → UserContext.setUserId()
  → PrismaService.withCurrentUser() → SET LOCAL app.current_user_id
  → PostgreSQL RLS policies
```

### Bypass Mechanisms
- SYSTEM context: `withoutRls()` - dla public API z token validation
- Superuser client: migrations/seeds tylko

## Struktura Monorepo

```
/
├── apps/
│   ├── api/          # NestJS backend (źródło prawdy dla API)
│   └── web/          # React frontend (planowany)
├── docs/
│   ├── specifications/  # Specyfikacje zmian
│   ├── security/       # Security guidelines
│   └── ecosystem.md    # ← TEN PLIK
└── research/          # Research notes
```
```

### 2. Status specyfikacji nieprawidłowy

**Problem:**
- SPEC-001 ma status "Draft"
- Implementation Notes (sekcja 9) mówi "FULLY IMPLEMENTED"
- TODO.md ma "[~]" (in progress)

**Jak naprawić:**
1. Zmień status w SPEC-001 na: `Status: Completed (2025-12-25)`
2. Zaktualizuj TODO.md: `[x]` dla SPEC-001
3. Dodaj sekcję "Completed" w docs/specifications/README.md

### 3. Brak katalogu ADR

**Problem:**
- docs/README.md wskazuje na `docs/adr/` w sekcji "Decyzje architektoniczne"
- Katalog nie istnieje
- Implementacja RLS zawiera decyzje architektoniczne wymagające ADR

**Jak naprawić:**
Utworzyć `docs/adr/README.md`:
```markdown
# Architecture Decision Records

## Active

| ADR | Title | Date | Status |
|-----|-------|------|--------|
| [ADR-001](ADR-001-row-level-security-implementation.md) | RLS Implementation Strategy | 2025-12-25 | Accepted |
| [ADR-002](ADR-002-asynclocalstorage-user-context.md) | AsyncLocalStorage for User Context | 2025-12-25 | Accepted |

## Deprecated

(none)

## Superseded

(none)
```

Utworzyć `docs/adr/ADR-001-row-level-security-implementation.md`:
```markdown
# ADR-001: Row Level Security Implementation Strategy

**Date:** 2025-12-25
**Status:** Accepted
**Context:** SPEC-001 Row Level Security implementation

## Context

Knowledge Forge is a multi-tenant SaaS application requiring strict data isolation. We need defense-in-depth security to ensure users cannot access data from other workspaces, even if application code has bugs.

## Decision

Implement PostgreSQL Row Level Security (RLS) with the following architecture:

1. **Non-superuser database role** (`knowledge_forge_app`) - enforces RLS
2. **Session variable** (`app.current_user_id`) - set per transaction
3. **Separate policies per operation** (SELECT/INSERT/UPDATE/DELETE)
4. **Direct column comparison for INSERT** - avoids chicken-and-egg problem
5. **AsyncLocalStorage** - request-scoped user context isolation

### Key Implementation Choices

**Why non-superuser role?**
- PostgreSQL superuser always bypasses RLS
- Production-like environment during development
- Catches RLS issues early

**Why AsyncLocalStorage instead of transaction parameter passing?**
- Cleaner API: `prisma.withCurrentUser()` vs `prisma.forUser(req.user.id)`
- Automatic context propagation through async call stack
- Prevents accidental context leakage between concurrent requests

**Why `createdById` column in Workspace?**
- INSERT policies cannot use subqueries (chicken-and-egg)
- Direct comparison works: `WITH CHECK (createdById = get_current_user_id())`
- Follows core-platform pattern

**Why SYSTEM context instead of separate DB role?**
- Simpler infrastructure (one database user)
- Explicit in code: `withoutRls()` clearly marks dangerous operation
- All public API access requires token validation before bypass

## Alternatives Considered

### Alternative 1: Application-level filtering only
- **Rejected:** No defense-in-depth
- Single bug exposes all tenant data

### Alternative 2: Separate database per tenant
- **Rejected:** Operational complexity
- Difficult migrations, backups, analytics

### Alternative 3: Middleware sets DB role per request
- **Rejected:** PostgreSQL role switching has significant overhead
- RLS with session variables performs better

### Alternative 4: Pass userId to every repository method
- **Rejected:** Boilerplate, easy to forget
- AsyncLocalStorage is safer

## Consequences

### Positive
- Defense-in-depth security at database level
- Production-like development environment
- Automatic context isolation per request
- Comprehensive test coverage (26/26 tests)

### Negative
- Slight performance overhead (indexed, cached queries mitigate this)
- More complex migrations (10 iterations to get INSERT policy right)
- Requires careful review of `withoutRls()` usage

### Trade-offs
- **Performance vs Security:** Chose security (indexed workspace lookups)
- **Simplicity vs Safety:** Chose safety (AsyncLocalStorage over parameter passing)
- **Flexibility vs Isolation:** Chose isolation (RLS always enforced for app user)

## Validation

- 26/26 integration tests passing
- Stress test: 50+ parallel operations maintain isolation
- Context switching test: rapid user switches without leakage
- ID manipulation test: direct access blocked by RLS

## Related

- SPEC-001: Row Level Security specification
- Migration: 20251225140000_fix_workspace_rls (final solution)
```

Utworzyć `docs/adr/ADR-002-asynclocalstorage-user-context.md`:
```markdown
# ADR-002: AsyncLocalStorage for User Context

**Date:** 2025-12-25
**Status:** Accepted
**Context:** SPEC-001 RLS implementation - user context management

## Context

RLS requires setting `app.current_user_id` session variable for every database query. We need a mechanism to:
1. Extract user ID from JWT token
2. Propagate it through async call chain
3. Isolate context per HTTP request (prevent leakage)

## Decision

Use Node.js AsyncLocalStorage for request-scoped user context management.

**Implementation:**
```typescript
// UserContext service
private readonly storage = new AsyncLocalStorage<{ userId: string }>();

getCurrentUserId(): string {
  const store = this.storage.getStore();
  if (!store?.userId) {
    throw new Error('User context not set');
  }
  return store.userId;
}

// RlsMiddleware
if (user?.sub) {
  this.userContext.setUserId(user.sub);
}

// PrismaService
async withCurrentUser<T>(callback: (tx) => Promise<T>): Promise<T> {
  const userId = this.userContext.getCurrentUserId();
  return this.forUser(userId, callback);
}
```

## Alternatives Considered

### Alternative 1: Pass userId to every method
```typescript
async getDocuments(userId: string, workspaceId: string)
```
- **Rejected:** Boilerplate, easy to forget parameter
- Risk of using wrong userId

### Alternative 2: cls-hooked (continuation-local-storage)
- **Rejected:** Deprecated, maintenance risk
- AsyncLocalStorage is native Node.js API (stable since v16)

### Alternative 3: Global variable
- **Rejected:** Not thread-safe, context leakage between requests
- Impossible to test concurrent scenarios

### Alternative 4: Nest.js REQUEST scope providers
- **Rejected:** Performance overhead (creates new instance per request)
- Doesn't propagate through background jobs naturally

## Consequences

### Positive
- Automatic context propagation through async stack
- Type-safe: compile-time check for getCurrentUserId() calls
- Works with background jobs: `runWithUser(userId, () => job())`
- Native Node.js API (no dependencies)

### Negative
- Requires understanding of AsyncLocalStorage semantics
- Must be initialized in middleware (before any service calls)

### Trade-offs
- **Explicitness vs Safety:** Implicit context is safer than passing parameters
- **Performance vs Convenience:** Negligible overhead for major DX improvement

## Validation

- All 26 RLS tests use AsyncLocalStorage
- Stress test: 50+ concurrent requests maintain isolation
- Context switching test: rapid user changes without leakage

## Related

- ADR-001: RLS Implementation Strategy
- SPEC-001: Row Level Security
```

## High Priority (brakująca kluczowa dokumentacja)

### 1. Brak dokumentacji w docs/README.md dla security implementations

**Problem:**
- docs/README.md odwołuje się do `docs/security/` (exists)
- Ale nie ma konkretnego linku do RLS documentation
- SPEC-020 (Tenant User Lookup) jest zaimplementowany ale nie wymieniony w README

**Jak naprawić:**

Dodać do docs/README.md po sekcji "Specyfikacje":

```markdown
## Zaimplementowane Feature'y

| Feature | Specyfikacja | Status | Dokumentacja |
|---------|--------------|--------|--------------|
| Row-Level Security | [SPEC-001](specifications/SPEC-001-row-level-security.md) | Completed | [ADR-001](adr/ADR-001-row-level-security-implementation.md) |
| Tenant User Lookup | [SPEC-020](specifications/SPEC-020-tenant-user-lookup.md) | Completed | (inline w spec) |
```

### 2. Brak dokumentacji API dla RLS endpoints

**Problem:**
- main.ts konfiguruje Swagger: `/api/docs`
- Ale brak informacji w README jak uruchomić/odczytać dokumentację
- Brak przykładów użycia RLS-aware endpoints

**Jak naprawić:**

Dodać do apps/api/README.md (jeśli nie istnieje - utworzyć):

```markdown
# Knowledge Forge API

## Quick Start

```bash
# Install dependencies
pnpm install

# Setup database
cp .env.example .env
# Edit .env with your DATABASE_URL and DATABASE_URL_MIGRATE

# Run migrations
pnpm prisma migrate deploy

# Seed database
pnpm prisma db seed

# Start development server
pnpm dev
```

## API Documentation

Swagger UI: http://localhost:6200/api/docs

## Row-Level Security (RLS)

All authenticated endpoints automatically enforce RLS. User can only access data from their workspaces.

### Development Mode

Uses non-superuser database role (`knowledge_forge_app`) to enforce RLS even in development.

**Environment variables:**
```bash
# Application database user (RLS enforced)
DATABASE_URL="postgresql://knowledge_forge_app:password@localhost:6201/knowledge_forge"

# Superuser for migrations only
DATABASE_URL_MIGRATE="postgresql://postgres:password@localhost:6201/knowledge_forge"
```

### Testing RLS

```bash
# Run RLS integration tests
pnpm test rls.integration.spec.ts

# All tests
pnpm test
```

**Test coverage:** 26/26 RLS tests passing
- Workspace isolation
- Document isolation
- Chunk isolation
- ID manipulation blocking
- Public API bypass
- Stress tests (50+ concurrent operations)

### RLS in Code

```typescript
// Authenticated endpoint - RLS enforced automatically
@UseGuards(JwtAuthGuard)
@Get('workspaces/:id/documents')
async getDocuments(@Param('id') workspaceId: string) {
  // RlsMiddleware already set user context
  return this.prisma.withCurrentUser(async (tx) => {
    return tx.document.findMany({
      where: { workspaceId }
      // RLS policy will filter to user's workspaces only
    });
  });
}

// Public endpoint - explicit RLS bypass with validation
@Public()
@Get('public/:token/search')
async searchPublic(@Param('token') token: string) {
  // First validate token
  const publicLink = await this.validateToken(token);

  // Then bypass RLS for public access
  return this.prisma.withoutRls(async (tx) => {
    return tx.document.findMany({
      where: { workspaceId: publicLink.workspaceId }
      // Manual filtering instead of RLS
    });
  });
}
```

## Architecture

Knowledge Forge follows Clean Architecture:

```
src/
├── domain/           # Entities, Value Objects, Domain Services
├── application/      # Use Cases, Application Services
├── infrastructure/   # Adapters (Prisma, OpenAI, B2)
│   └── persistence/
│       ├── prisma/   # ORM client
│       └── rls/      # RLS middleware, UserContext
└── interfaces/       # Controllers, DTOs
    └── http/
```

See [docs/ecosystem.md](../../docs/ecosystem.md) for full architecture overview.
```

### 3. Brak dokumentacji dla TenantUserEmailLookup w README

**Problem:**
- SPEC-020 jest "In Progress" ale większość zadań COMPLETED
- Nie ma wzmianki o tej feature w głównych plikach README
- Brak informacji jak feature wpływa na auth flow

**Jak naprawić:**

Zaktualizować SPEC-020 status z "In Progress" na:
```markdown
**Status:** Completed (TASK-6 pending)
```

Dodać do docs/specifications/README.md:
```markdown
| 020 | [Tenant User Lookup](./SPEC-020-tenant-user-lookup.md) | P0 | S | Completed (tests pending) |
```

## Medium Priority (do uzupełnienia)

### 1. Dokumentacja testów wydajnościowych

**Problem:**
- SPEC-001 DoD wymaga "Testy wydajnościowe (benchmark przed/po RLS)"
- Brak dokumentacji czy testy zostały wykonane
- Brak wyników performance benchmarks

**Jak naprawić:**

Dodać sekcję do SPEC-001 (lub osobny plik docs/benchmarks/rls-performance.md):

```markdown
## Performance Benchmarks

### Setup
- PostgreSQL 16
- pgvector extension
- Database: 1000 workspaces, 10000 documents, 50000 chunks
- Concurrent users: 50

### Results

| Operation | Without RLS | With RLS | Overhead |
|-----------|-------------|----------|----------|
| Find workspace by ID | 2.3ms | 2.8ms | +21% |
| List documents (workspace) | 15ms | 18ms | +20% |
| Semantic search (10 results) | 45ms | 48ms | +6.7% |
| Concurrent requests (50 users) | 850ms p95 | 920ms p95 | +8.2% |

### Optimizations Applied
- Index on Workspace.id, Document.workspaceId
- STABLE function: get_user_workspace_ids()
- Query plan caching for RLS policies

### Conclusion
RLS overhead is acceptable (<25%) and offset by security benefits.
Semantic search (main use case) has minimal impact (+6.7%).
```

### 2. Brak przykładów użycia w dokumentacji

**Problem:**
- SPEC-001 pokazuje kod, ale brak end-to-end przykładów
- Trudno zrozumieć pełny flow dla nowego developera

**Jak naprawić:**

Dodać sekcję do SPEC-001 lub apps/api/README.md:

```markdown
## RLS Examples - End to End

### Example 1: Create Workspace

```bash
# 1. Register user
POST /api/v1/auth/register
{
  "email": "alice@example.com",
  "password": "secure123",
  "name": "Alice"
}
Response: { "user": { "id": "user-abc", "email": "alice@example.com" }, "token": "jwt-token" }

# 2. Login
POST /api/v1/auth/login
{
  "email": "alice@example.com",
  "password": "secure123"
}
Response: { "token": "jwt-xyz", "user": { ... } }

# 3. Create workspace (RLS enforced automatically)
POST /api/v1/workspaces
Headers: { "Authorization": "Bearer jwt-xyz" }
{
  "name": "My Knowledge Base"
}
Response: { "id": "ws-123", "name": "My Knowledge Base", "createdById": "user-abc" }

# Behind the scenes:
# - JwtAuthGuard validates token
# - RlsMiddleware sets UserContext.userId = "user-abc"
# - WorkspaceService.create() uses withCurrentUser()
# - PostgreSQL SET LOCAL app.current_user_id = 'user-abc'
# - INSERT policy checks: createdById = 'user-abc' ✓
# - WorkspaceMember created with OWNER role
```

### Example 2: RLS Blocks Unauthorized Access

```bash
# Alice tries to access Bob's workspace
GET /api/v1/workspaces/ws-bob-456/documents
Headers: { "Authorization": "Bearer alice-jwt" }

# Behind the scenes:
# - RlsMiddleware sets UserContext.userId = "alice-id"
# - PrismaService.withCurrentUser() sets app.current_user_id = 'alice-id'
# - PostgreSQL RLS policy: WHERE workspaceId IN (SELECT get_user_workspace_ids())
# - get_user_workspace_ids() returns ['ws-123'] (only Alice's workspace)
# - ws-bob-456 is filtered out by RLS
# - Query returns empty array

Response: []  # Not 403 - RLS makes it invisible
```

### Example 3: Public API with Token

```bash
# Create public link (authenticated)
POST /api/v1/workspaces/ws-123/public-links
Headers: { "Authorization": "Bearer alice-jwt" }
{
  "name": "Public Knowledge Base"
}
Response: { "token": "pub-token-xyz", "workspaceId": "ws-123" }

# Public search (no auth required)
POST /api/v1/public/pub-token-xyz/search
{
  "query": "How to deploy?"
}

# Behind the scenes:
# - No JWT, no RlsMiddleware
# - PublicController validates token first
# - Uses withoutRls() to bypass RLS
# - Manual filtering by publicLink.workspaceId
# - Returns results without RLS restrictions

Response: { "results": [ ... ] }
```
```

### 3. Code comments nie zawsze wyjaśniają "why"

**Problem:**
- PrismaService ma dobre komentarze JSDoc
- Ale niektóre decyzje implementacyjne nie są wyjaśnione

**Przykład:**

Migration `20251225140000_fix_workspace_rls/migration.sql`:
```sql
-- SELECT: Can see workspaces where you're a member OR you created it
CREATE POLICY workspace_select ON "Workspace"
  FOR SELECT
  TO PUBLIC
  USING (
    id IN (SELECT * FROM get_user_workspace_ids())
    OR "createdById" = get_current_user_id()
  );
```

**Why `OR createdById`?**
- Not explained in migration
- Critical for workspace creation flow
- Should reference chicken-and-egg problem

**Jak naprawić:**

Update migration comment:
```sql
-- SELECT: Can see workspaces where you're a member OR you created it
-- Note: The "OR createdById" clause is critical for workspace creation flow:
-- 1. User creates workspace (INSERT succeeds via createdById check)
-- 2. WorkspaceMember is created (separate INSERT)
-- 3. Before step 2 completes, user must see workspace (via createdById)
-- 4. After step 2 completes, user sees workspace (via member check)
-- This solves the chicken-and-egg problem of INSERT policies.
```

## Low Priority (sugestie)

### 1. TODO.md mentions enterprise features removed

**Obserwacja:**
- TODO.md: "SPEC-003/004/005 przeniesione do repozytorium enterprise"
- docs/README.md: "Enterprise Research: przeniesione do prywatnego repozytorium"
- But no explanation what features are community vs enterprise

**Sugestia:**

Dodać do docs/README.md:

```markdown
## Community vs Enterprise

Knowledge Forge ma otwarte źródło (community) + płatne rozszerzenia (enterprise).

### Community Edition (MIT License)
- Row-Level Security (multi-tenancy)
- Document management (upload, markdown, tags)
- Semantic search (RAG with pgvector)
- Public link sharing
- REST API + Swagger docs

### Enterprise Edition (Commercial)
- Usage tracking & limits per plan (FREE/STARTER/BASIC/PRO/BUSINESS)
- Billing integration
- Admin dashboard
- Advanced analytics
- SSO/SAML
- Conflict detection (PREMIUM)
- Verified recommendations (PREMIUM)

**Repo:** https://github.com/kuklatech/knowledge-forge-enterprise (private)
```

### 2. Brak contributing guidelines

**Obserwacja:**
- Open-source project (według docs/research/open-source-best-practices-2025.md)
- Brak CONTRIBUTING.md

**Sugestia:**

Utworzyć CONTRIBUTING.md:
```markdown
# Contributing to Knowledge Forge

## Code of Conduct

Be respectful. We're all learning.

## Development Setup

See [apps/api/README.md](apps/api/README.md) for setup instructions.

## Coding Standards

- Follow Clean Architecture (domain/application/infrastructure/interfaces)
- Write tests first (TDD)
- Use Conventional Commits (feat:, fix:, docs:, refactor:, test:)
- All timestamps: `timestamp with time zone`

## Security

- NEVER bypass RLS without token validation
- ALWAYS use `withCurrentUser()` in authenticated endpoints
- ALWAYS validate input (ValidationPipe, DTOs)
- ALWAYS use prepared statements (Prisma handles this)

## Pull Request Process

1. Fork the repository
2. Create feature branch: `git checkout -b feat/my-feature`
3. Write tests (run: `pnpm test`)
4. Commit changes: `git commit -m "feat: add my feature"`
5. Push: `git push origin feat/my-feature`
6. Open PR with description linking to issue/spec

## Specifications

Before implementing a feature:
1. Check docs/specifications/ for existing spec
2. If none exists, create SPEC-NNN-feature-name.md following template
3. Get spec reviewed before coding

## Questions?

Open a GitHub Discussion or issue.
```

### 3. Swagger docs może mieć więcej przykładów

**Obserwacja:**
- Swagger setup exists (main.ts, DTOs have ApiProperty)
- Ale brak przykładów request/response w dokumentacji

**Sugestia:**

Update DTOs with `@ApiProperty({ example: ... })`:

```typescript
// workspace.dto.ts
export class CreateWorkspaceDto {
  @ApiProperty({
    description: 'Workspace name',
    example: 'My Knowledge Base',
    minLength: 1,
    maxLength: 100
  })
  @IsString()
  @MinLength(1)
  name: string;
}

export class WorkspaceResponseDto {
  @ApiProperty({ example: 'ws-123e4567-e89b-12d3-a456-426614174000' })
  id: string;

  @ApiProperty({ example: 'My Knowledge Base' })
  name: string;

  @ApiProperty({ example: 'user-123e4567-e89b-12d3-a456-426614174000' })
  createdById: string;

  @ApiProperty({ example: '2025-12-25T12:00:00Z' })
  createdAt: Date;
}
```

## Co jest dobrze udokumentowane

### 1. Implementation Notes w SPEC-001

SPEC-001 sekcja 9 (Implementation Notes) jest WZORCOWA:
- Dokładny opis finalnego rozwiązania
- Lista wszystkich 10 migracji z wyjaśnieniem
- Komponenty systemu z ich rolami
- Konfiguracja database z przykładami
- Test results: 26/26 PASSING
- Key learnings (chicken-and-egg problem, superuser bypass, etc.)
- Current status jasno określony

### 2. Comprehensive JSDoc w kodzie

PrismaService (`apps/api/src/infrastructure/persistence/prisma/prisma.service.ts`):
- Każda metoda ma pełny JSDoc
- Przykłady użycia w @example
- Wyjaśnienie parametrów
- Ostrzeżenia dla `withoutRls()` (DANGEROUS)

UserContext (`apps/api/src/infrastructure/persistence/rls/user.context.ts`):
- Jasne wyjaśnienie AsyncLocalStorage
- Przykłady dla middleware i background jobs
- Dokumentacja error handling

### 3. RLS Integration Tests

Test file (`apps/api/src/infrastructure/persistence/rls/__tests__/rls.integration.spec.ts`):
- Komentarz na początku wyjaśnia setup (real DB, not mocks)
- Każdy test suite ma jasny opis scenariusza
- Testy są self-documenting (readable)
- Stress tests pokazują skalę (50+ concurrent)

### 4. SPEC-020 Agent Progress Log

SPEC-020 ma sekcję "Agent Progress Log" z timestampami:
- Kto (który agent)
- Kiedy (timestamp)
- Co (task number)
- Szczegóły (co zostało zrobione)

To ŚWIETNY pattern do trackowania implementacji.

### 5. Swagger setup w main.ts

```typescript
const config = new DocumentBuilder()
  .setTitle('Knowledge Forge API')
  .setDescription('Knowledge Base with RAG capabilities')
  .setVersion('1.0')
  .addBearerAuth()
  .build();
```

Prosty, czytelny, działa out-of-the-box.

## Wymagane aktualizacje

| Dokument | Co zaktualizować | Priorytet |
|----------|------------------|-----------|
| **docs/ecosystem.md** | **UTWORZYĆ** - mapa systemu (Bounded Contexts, Event Bus, Source of Truth) | CRITICAL |
| **docs/adr/** | **UTWORZYĆ** katalog + ADR-001 (RLS) + ADR-002 (AsyncLocalStorage) | CRITICAL |
| **SPEC-001** | Zmienić status z "Draft" na "Completed (2025-12-25)" | CRITICAL |
| **TODO.md** | Zmienić "[~]" na "[x]" dla SPEC-001 | CRITICAL |
| **docs/README.md** | Dodać sekcję "Zaimplementowane Feature'y" z linkami do ADR | HIGH |
| **docs/README.md** | Dodać SPEC-020 do listy specyfikacji | HIGH |
| **apps/api/README.md** | **UTWORZYĆ** - setup, RLS explanation, examples | HIGH |
| **SPEC-020** | Zmienić status z "In Progress" na "Completed (tests pending)" | HIGH |
| **docs/specifications/README.md** | Dodać SPEC-020 do tabeli | HIGH |
| **SPEC-001 or separate file** | Dodać performance benchmarks (DoD requirement) | MEDIUM |
| **SPEC-001 or README** | Dodać end-to-end examples (create workspace, RLS blocks access) | MEDIUM |
| **Migration 20251225140000** | Rozszerzyć komentarz wyjaśniający "OR createdById" logic | MEDIUM |
| **docs/README.md** | Dodać sekcję "Community vs Enterprise" | LOW |
| **CONTRIBUTING.md** | **UTWORZYĆ** - contributing guidelines | LOW |
| **DTOs** | Dodać `@ApiProperty({ example: ... })` do wszystkich DTOs | LOW |

## Sugestie ulepszeń dokumentacji

### 1. Progressive Disclosure - ecosystem.md as index

**Problem:**
Dokumentacja jest płaska - ciężko znaleźć co trzeba.

**Sugestia:**
Użyć ecosystem.md jako "mapy" z linkami do szczegółów:

```markdown
# docs/ecosystem.md

## Quick Navigation

- **New to the project?** Start with [apps/api/README.md](../apps/api/README.md)
- **Implementing a feature?** Check [specifications/README.md](specifications/README.md)
- **Making architecture decision?** See [adr/README.md](adr/README.md)
- **Security review?** Read [security/CODE_REVIEW_SECURITY_CHECKLIST.md](security/CODE_REVIEW_SECURITY_CHECKLIST.md)

## System Map

[... current content ...]

## Deep Dives

For implementation details:
- [RLS Implementation](adr/ADR-001-row-level-security-implementation.md)
- [Tenant Lookup](specifications/SPEC-020-tenant-user-lookup.md)
- [RAG Architecture](../research/RAG_Knowledge_Base_Research_2025.md)
```

### 2. Diagram dla RLS flow

**Obserwacja:**
RLS flow jest złożony (middleware → context → transaction → SQL).

**Sugestia:**
Dodać Mermaid diagram do SPEC-001 lub ecosystem.md:

```markdown
## RLS Request Flow

```mermaid
sequenceDiagram
    participant Client
    participant JwtAuthGuard
    participant RlsMiddleware
    participant Controller
    participant Service
    participant PrismaService
    participant PostgreSQL

    Client->>JwtAuthGuard: GET /workspaces (with JWT)
    JwtAuthGuard->>RlsMiddleware: req.user = { sub: 'user-123' }
    RlsMiddleware->>UserContext: setUserId('user-123')
    RlsMiddleware->>Controller: next()
    Controller->>Service: getWorkspaces()
    Service->>PrismaService: withCurrentUser((tx) => ...)
    PrismaService->>UserContext: getCurrentUserId()
    UserContext-->>PrismaService: 'user-123'
    PrismaService->>PostgreSQL: BEGIN; SET LOCAL app.current_user_id='user-123';
    PostgreSQL->>PostgreSQL: Apply RLS policies
    PostgreSQL-->>PrismaService: Results (filtered)
    PrismaService-->>Service: Results
    Service-->>Controller: Results
    Controller-->>Client: { workspaces: [...] }
```
```

### 3. "Troubleshooting" sekcja w README

**Obserwacja:**
RLS może być trudny do debugowania.

**Sugestia:**
Dodać do apps/api/README.md:

```markdown
## Troubleshooting RLS

### "User context not set" error

**Symptom:** `Error: User context not set. Ensure RlsMiddleware is properly configured.`

**Cause:** Using `withCurrentUser()` outside of HTTP request context.

**Fix:**
- Authenticated endpoints: Check that RlsMiddleware is registered in AppModule
- Background jobs: Use `forUser(userId, callback)` instead
- Tests: Use `prismaSuperuser` or `forUser(testUserId, callback)`

### RLS shows all data (isolation not working)

**Symptom:** User can see other workspaces' data.

**Cause:** Using superuser database role (bypasses RLS).

**Fix:**
- Check `DATABASE_URL` uses `knowledge_forge_app` user, not `postgres`
- Verify: `SELECT current_user;` should return `knowledge_forge_app`
- Verify RLS enabled: `SELECT relname, relrowsecurity FROM pg_class WHERE relname = 'Workspace';`

### INSERT fails with "new row violates row-level security policy"

**Symptom:** `ERROR: new row violates row-level security policy for table "Workspace"`

**Cause:** `createdById` doesn't match current user.

**Fix:**
```typescript
// Wrong
await tx.workspace.create({
  data: { name: 'Test', createdById: 'someone-else' }
});

// Correct
const userId = await userContext.getCurrentUserId();
await tx.workspace.create({
  data: { name: 'Test', createdById: userId }
});
```

### Performance degradation after RLS

**Symptom:** Queries are slow after enabling RLS.

**Debug:**
```sql
-- Check query plan
EXPLAIN ANALYZE
SELECT * FROM "Workspace"
WHERE id IN (SELECT * FROM get_user_workspace_ids());
```

**Common fixes:**
- Add index on workspaceId: `CREATE INDEX idx_workspace_id ON "Document"("workspaceId");`
- Mark function STABLE: `CREATE OR REPLACE FUNCTION get_user_workspace_ids() ... STABLE;`
- Increase work_mem: `SET work_mem = '64MB';`
```

### 4. Testing guide

**Obserwacja:**
RLS tests są świetne, ale brak dokumentacji jak pisać nowe.

**Sugestia:**
Dodać `docs/testing-guide.md`:

```markdown
# Testing Guide

## Writing RLS Tests

### Setup

Use two Prisma clients:
- `prisma` - regular client (RLS enforced) for testing isolation
- `prismaSuperuser` - superuser client for setup/teardown

```typescript
let prisma: PrismaService;
let prismaSuperuser: PrismaClient;

beforeAll(async () => {
  prisma = module.get<PrismaService>(PrismaService);

  prismaSuperuser = new PrismaClient({
    datasources: {
      db: { url: process.env.DATABASE_URL_MIGRATE }
    }
  });
});
```

### Test Pattern

```typescript
it('User A cannot access User B data', async () => {
  // Setup: Use superuser (bypasses RLS)
  const userA = await prismaSuperuser.user.create({ ... });
  const userB = await prismaSuperuser.user.create({ ... });
  const dataB = await prismaSuperuser.workspace.create({
    data: { ..., createdById: userB.id }
  });

  // Test: Use regular client with RLS
  const result = await prisma.forUser(userA.id, async (tx) => {
    return tx.workspace.findUnique({ where: { id: dataB.id } });
  });

  // Assert: RLS makes data invisible
  expect(result).toBeNull();

  // Cleanup: Use superuser
  await prismaSuperuser.workspace.delete({ where: { id: dataB.id } });
});
```

### Best Practices

1. **Always cleanup** - Use afterEach to delete test data
2. **Test null, not 404** - RLS returns null (makes data invisible)
3. **Test concurrent scenarios** - Use Promise.all to test isolation
4. **Use unique data** - Add uuid() to test data to avoid conflicts
5. **Verify both ways** - Test User A can't see B AND B can't see A
```

## Podsumowanie

### Status implementacji SPEC-001

**Ocena:** FULLY IMPLEMENTED (status w docs nieprawidłowy)

Implementacja jest kompletna i wysokiej jakości:
- 26/26 testy passing
- Production-ready (non-superuser role)
- Comprehensive code documentation
- Detailed implementation notes

**Wymagane:** Zmienić status dokumentacji na "Completed"

### Największe luki dokumentacyjne

1. **CRITICAL:** Brak ecosystem.md (mapa systemu)
2. **CRITICAL:** Brak ADR (decyzje architektoniczne)
3. **HIGH:** Brak apps/api/README.md (setup guide)
4. **HIGH:** Status specyfikacji nieaktualny

### Następne kroki

**Priorytet 1 (CRITICAL):**
1. Utworzyć docs/ecosystem.md z architekturą systemu
2. Utworzyć docs/adr/ + ADR-001 + ADR-002
3. Zmienić status SPEC-001 na "Completed"
4. Zmienić TODO.md "[~]" → "[x]"

**Priorytet 2 (HIGH):**
5. Utworzyć apps/api/README.md z setup + RLS examples
6. Zaktualizować docs/README.md o sekcję "Zaimplementowane Feature'y"
7. Dodać SPEC-020 do docs/specifications/README.md

**Priorytet 3 (MEDIUM):**
8. Dodać performance benchmarks
9. Rozszerzyć komentarze w migrations
10. Dodać end-to-end examples do SPEC-001

### Jakość obecnej dokumentacji

**Mocne strony:**
- Implementation Notes w SPEC-001 są wzorcowe
- JSDoc w kodzie bardzo dobry
- RLS tests są self-documenting
- SPEC-020 Agent Progress Log - świetny pattern

**Do poprawy:**
- Brak "mapy" systemu (ecosystem.md)
- Brak Progressive Disclosure
- Brak troubleshooting guides
- Brak przykładów end-to-end

### Rekomendacja

RLS implementation is **production-ready** from code perspective.
Documentation needs **critical updates** (ecosystem.md, ADR) before calling it "complete".

**Recommended next action:** Update documentation status to match implementation reality, then create missing architecture docs (ecosystem.md, ADR).
