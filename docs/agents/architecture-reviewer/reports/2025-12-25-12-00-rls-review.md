# Architecture Review Report - 2025-12-25

## Architecture Review Results

### Kontekst

- **Modu≈Ç:** Infrastructure (RLS), Application (Workspace, TenantLookup)
- **Bounded Context:** Multi-tenant Security & Data Isolation
- **Przeczytane ADR:** Brak formalnych ADR (projekt w fazie MVP)
- **PowiƒÖzane przep≈Çywy:**
  - User authentication ‚Üí RLS context setting ‚Üí Database queries
  - Workspace creation ‚Üí Member addition ‚Üí Email lookup sync
  - Public API ‚Üí RLS bypass (SYSTEM context)
- **G≈Ç√≥wna specyfikacja:** SPEC-001-row-level-security.md

### Zmienione pliki

**Schema & Migrations:**
- `apps/api/prisma/schema.prisma` - dodano `createdById` do Workspace, `TenantUserEmailLookup` model
- 9 migracji SQL (20251225102653 ‚Üí 20251225140000) - iteracyjne poprawki RLS policies

**Infrastructure Layer:**
- `apps/api/src/infrastructure/persistence/prisma/prisma.service.ts` - RLS wrappers
- `apps/api/src/infrastructure/persistence/rls/` - UserContext, RlsMiddleware, RlsBypassService
- `apps/api/src/infrastructure/crypto/hash.util.ts` - email hashing
- `apps/api/src/infrastructure/persistence/repositories/workspace.repository.impl.ts` - aktualizacja pod `createdById`

**Application Layer:**
- `apps/api/src/application/workspace/workspace.service.ts` - u≈ºycie `forUser()`, eventy
- `apps/api/src/application/tenant-lookup/` - nowy modu≈Ç (service, listener, events)

**API Layer:**
- `apps/api/src/app.module.ts` - rejestracja RlsMiddleware
- `apps/api/src/interfaces/http/tenant-lookup/` - controller, DTOs

---

## Ocena zgodno≈õci z zasadami architektonicznymi

### 1. Clean Architecture - Separacja warstw

#### ‚úÖ Dobre praktyki (EXCELLENT)

**Domain Layer pozostaje czysty:**
- `DocumentEntity` (apps/api/src/domain/document/document.entity.ts) - czysta logika biznesowa bez zale≈ºno≈õci od infrastruktury
- `Tag` Value Object - immutable, walidacja w konstruktorze
- `IWorkspaceRepository` interface w domenie - DIP compliance

**Infrastructure Layer prawid≈Çowo odizolowana:**
- RLS jako implementacja na poziomie infrastruktury (PostgreSQL policies)
- `PrismaService` jako adapter ORM
- `UserContext` u≈ºywa AsyncLocalStorage (Node.js specific) - prawid≈Çowo w infra

**Application Layer jako orchestrator:**
- `WorkspaceService` orkiestruje flow, deleguje do repository
- Emituje domain events (event-driven architecture)

#### üü° MEDIUM - Drobne naruszenia separacji

**Workspace.repository.impl bezpo≈õrednio u≈ºywa PrismaService:**
```typescript
// apps/api/src/infrastructure/persistence/repositories/workspace.repository.impl.ts
export class PrismaWorkspaceRepository implements IWorkspaceRepository {
  constructor(private readonly prisma: PrismaService) {} // ‚úÖ OK - repository jest w infra

  async findByUserId(userId: string): Promise<WorkspaceWithMembers[]> {
    return this.prisma.workspace.findMany({ // ‚ùå Brak RLS context!
      where: { members: { some: { userId } } }
    });
  }
}
```

**Problem:** `PrismaWorkspaceRepository` u≈ºywa `this.prisma` bezpo≈õrednio zamiast `this.prisma.forUser()`. To **omija RLS** i mo≈ºe prowadziƒá do data leakage.

**Jak naprawiƒá:**
```typescript
async findByUserId(userId: string): Promise<WorkspaceWithMembers[]> {
  return this.prisma.forUser(userId, async (tx) => {
    return tx.workspace.findMany({
      where: { members: { some: { userId } } },
      include: { members: { include: { user: true } } }
    });
  });
}
```

**Uwaga:** W praktyce mo≈ºe dzia≈Çaƒá, bo RLS jest wymuszane na poziomie DB, ale:
1. Niesp√≥jne z resztƒÖ kodu (WorkspaceService u≈ºywa `forUser()`)
2. Utrudnia testowanie (brak wyra≈∫nego kontraktu)
3. ≈Åamie konwencjƒô - kod powinien byƒá self-documenting

---

### 2. DDD Compliance

#### ‚úÖ Dobre praktyki

**DocumentEntity jako Aggregate Root:**
- Kontroluje cykl ≈ºycia dokumentu (`startProcessing()`, `completeProcessing()`, `failProcessing()`)
- Wymusza invarianty (nie mo≈ºna usunƒÖƒá dokumentu w trakcie przetwarzania)
- Enkapsulacja - modyfikacja tylko przez publiczne metody
- Prawid≈Çowa factory pattern: `create()` i `reconstitute()`

**Tag jako Value Object:**
- Immutable (private readonly value)
- Walidacja w konstruktorze (`length > 0 && length <= 50`)
- Equality przez warto≈õƒá (`equals()`)
- Self-validating

**Domain Events (event-driven):**
```typescript
// WorkspaceService emituje eventy:
this.eventEmitter.emit('workspace.member.added',
  new WorkspaceMemberAddedEvent(userId, workspace.id)
);
```
- Nazewnictwo w czasie przesz≈Çym ‚úÖ
- Immutable event objects ‚úÖ
- Decoupling - TenantLookupListener reaguje asynchronicznie ‚úÖ

#### üî¥ CRITICAL - Brak Workspace Aggregate

**Problem:** `Workspace` nie istnieje jako domain entity - tylko Prisma model.

```typescript
// apps/api/src/application/workspace/workspace.service.ts
async create(userId: string, dto: CreateWorkspaceDto) {
  const workspace = await this.prisma.forUser(userId, async (tx) => {
    return tx.workspace.create({ // ‚ùå Anemic Domain Model - logika w serwisie
      data: {
        name: dto.name,
        createdById: userId,
        members: { create: { userId, role: Role.OWNER } }
      }
    });
  });
}
```

**Co jest nie tak:**
- Brak walidacji biznesowej (workspace name nie mo≈ºe byƒá pusty, d≈Çugo≈õƒá?)
- Brak enkapsulacji (bezpo≈õrednia manipulacja Prisma)
- Logika biznesowa "workspace owner jest dodawany jako member" jest w service layer
- Brak domain events z poziomu agregatu (emitowane rƒôcznie z service)

**Jak powinno byƒá (DDD):**

```typescript
// domain/workspace/workspace.entity.ts
export class WorkspaceEntity {
  private constructor(private props: WorkspaceProps) {}

  static create(name: string, ownerId: string): WorkspaceEntity {
    if (!name || name.trim().length === 0) {
      throw new Error('Workspace name cannot be empty');
    }
    if (name.length > 100) {
      throw new Error('Workspace name too long');
    }

    const workspace = new WorkspaceEntity({
      id: '', // set by repository
      name: name.trim(),
      createdById: ownerId,
      members: [{ userId: ownerId, role: Role.OWNER }],
      createdAt: new Date(),
      updatedAt: new Date()
    });

    // Emit domain event
    workspace.addDomainEvent(new WorkspaceCreatedEvent(workspace.id, ownerId));
    return workspace;
  }

  addMember(userId: string, role: Role): void {
    if (this.members.some(m => m.userId === userId)) {
      throw new Error('User already a member');
    }
    this.members.push({ userId, role });
    this.addDomainEvent(new WorkspaceMemberAddedEvent(this.id, userId));
  }
}
```

**Impact:** HIGH - to fundamentalna zasada DDD. Workspace jest kluczowym konceptem biznesowym (tenant w multi-tenancy).

#### üü† HIGH - Repository Pattern nie jest w pe≈Çni wykorzystany

**Problem:** `WorkspaceService` bezpo≈õrednio u≈ºywa `PrismaService` zamiast `IWorkspaceRepository`.

```typescript
// workspace.service.ts
constructor(
  private readonly prisma: PrismaService, // ‚ùå Bezpo≈õrednia zale≈ºno≈õƒá od infra
  private readonly eventEmitter: EventEmitter2
) {}

async findAllForUser(userId: string) {
  return this.prisma.forUser(userId, async (tx) => { // ‚ùå Ominiƒôcie repository
    return tx.workspace.findMany({ ... });
  });
}
```

**Dlaczego to problem:**
1. Application layer zale≈ºy od Infrastructure (odwr√≥cenie Clean Architecture)
2. Trudniej testowaƒá (trzeba mockowaƒá PrismaService zamiast prostego interface)
3. Repository pattern istnieje (`PrismaWorkspaceRepository`), ale nie jest u≈ºywany

**Jak naprawiƒá:**
```typescript
// workspace.service.ts
constructor(
  @Inject(WORKSPACE_REPOSITORY) private readonly repository: IWorkspaceRepository,
  private readonly eventEmitter: EventEmitter2
) {}

async findAllForUser(userId: string) {
  return this.repository.findByUserId(userId); // ‚úÖ Delegacja do repository
}
```

---

### 3. SOLID Principles

#### ‚úÖ SRP (Single Responsibility Principle) - GOOD

**Ka≈ºda klasa ma jednƒÖ odpowiedzialno≈õƒá:**
- `UserContext` - zarzƒÖdzanie user context (AsyncLocalStorage)
- `RlsMiddleware` - ekstrakcja user z JWT i ustawienie context
- `PrismaService` - wrappers dla RLS transactions
- `RlsBypassService` - bypass RLS dla public API
- `TenantLookupService` - email ‚Üí workspaces mapping
- `WorkspaceService` - orkiestracja workspace operations

#### ‚úÖ OCP (Open/Closed Principle) - GOOD

**RLS extensible bez modyfikacji:**
```typescript
// Nowa strategia RLS? Dodaj metodƒô do PrismaService
async forTenant<T>(tenantId: string, callback: ...) {
  // set tenant context zamiast user context
}
```

**TenantLookup mo≈ºe mieƒá wiele strategii:**
- Email hash lookup (obecne)
- Subdomain resolution (przysz≈Çe)
- localStorage fallback (frontend)

#### üü° MEDIUM - LSP (Liskov Substitution Principle)

**PrismaWorkspaceRepository implementuje IWorkspaceRepository:**
```typescript
interface IWorkspaceRepository {
  findByUserId(userId: string): Promise<WorkspaceWithMembers[]>;
}

class PrismaWorkspaceRepository implements IWorkspaceRepository {
  async findByUserId(userId: string): Promise<WorkspaceWithMembers[]> {
    return this.prisma.workspace.findMany({ // ‚ö†Ô∏è Brak RLS context
      where: { members: { some: { userId } } }
    });
  }
}
```

**Problem:** Je≈õli kto≈õ podmieni `PrismaWorkspaceRepository` na innƒÖ implementacjƒô (np. `InMemoryWorkspaceRepository` dla test√≥w), mo≈ºe nie dzia≈Çaƒá RLS. Interface nie gwarantuje security constraints.

**Sugestia:** Interface powinien przyjmowaƒá userId jako kontekst RLS:
```typescript
interface IWorkspaceRepository {
  findByUserId(userId: string, context: SecurityContext): Promise<...>;
}
```

Lub u≈ºyƒá Dependency Injection dla RLS context.

#### ‚úÖ ISP (Interface Segregation Principle) - EXCELLENT

**Ma≈Çe, skupione interfejsy:**
- `IWorkspaceRepository` - tylko workspace operations
- Repository nie zmusza klient√≥w do implementacji zbƒôdnych metod

#### ‚úÖ DIP (Dependency Inversion Principle) - GOOD

**Zale≈ºno≈õci od abstrakcji:**
```typescript
export const WORKSPACE_REPOSITORY = Symbol('IWorkspaceRepository');
// Service zale≈ºy od interface, nie implementacji (teoria)
```

**Jednak w praktyce:**
```typescript
// workspace.service.ts
constructor(private readonly prisma: PrismaService) // ‚ùå Konkretna klasa, nie interface
```

Wiƒôc DIP jest naruszane w WorkspaceService. Powinno byƒá:
```typescript
constructor(@Inject(WORKSPACE_REPOSITORY) private readonly repository: IWorkspaceRepository)
```

---

### 4. Enterprise Patterns

#### ‚úÖ EXCELLENT - Multi-tenancy: Database RLS Pattern

**Wzorzec:** Row Level Security jako Database-per-Tenant alternatywa (shared database, tenant isolation via policies).

**Implementacja:**
- PostgreSQL RLS policies na poziomie bazy
- `app.current_user_id` session variable
- `FORCE ROW LEVEL SECURITY` - wymusza RLS nawet dla superusera
- Non-superuser database account (`knowledge_forge_app`)

**Zgodno≈õƒá z enterprise best practices:**
- ‚úÖ Defense in depth (RLS + application-level checks)
- ‚úÖ Fail-safe defaults (brak context = brak dostƒôpu)
- ‚úÖ Separation of privileges (superuser tylko dla migracji)

**Wzorcowy przyk≈Çad z dokumentacji:**
> "For INSERT policies, use direct column comparison (createdById = get_current_user_id()) not subquery"

Ten insight zosta≈Ç poprawnie zastosowany w finalnej migracji:
```sql
-- 20251225140000_fix_workspace_rls/migration.sql
CREATE POLICY workspace_insert ON "Workspace"
  FOR INSERT WITH CHECK ("createdById" = get_current_user_id()); -- ‚úÖ Correct!
```

**Dlaczego to dzia≈Ça (lekcja z implementacji):**
- Subquery `id IN (SELECT get_user_workspace_ids())` ma problem chicken-and-egg dla INSERT (workspace nie istnieje jeszcze w WorkspaceMember)
- Direct value comparison dzia≈Ça, bo `createdById` jest kolumnƒÖ w insercie

#### ‚úÖ GOOD - Unit of Work Pattern (Implicit)

**Prisma transactions jako Unit of Work:**
```typescript
async forUser<T>(userId: string, callback: (tx: TransactionClient) => Promise<T>) {
  return this.$transaction(async (tx) => {
    await tx.$executeRaw`SELECT set_config('app.current_user_id', ${userId}::text, true)`;
    return callback(tx);
  });
}
```

- Transaction boundary ‚úÖ
- Rollback on error ‚úÖ
- Isolation (user context scoped to transaction) ‚úÖ

#### üü° MEDIUM - Repository Pattern (Partial)

**Istnieje, ale nie jest konsekwentnie u≈ºywany:**
- `IWorkspaceRepository` zdefiniowany w domain layer ‚úÖ
- `PrismaWorkspaceRepository` w infrastructure layer ‚úÖ
- **ALE** `WorkspaceService` u≈ºywa `PrismaService` bezpo≈õrednio ‚ùå

**Sugestia:** Enforce repository usage przez DI:
```typescript
@Module({
  providers: [
    { provide: WORKSPACE_REPOSITORY, useClass: PrismaWorkspaceRepository },
    WorkspaceService
  ]
})
```

#### ‚úÖ EXCELLENT - Request Context Pattern

**AsyncLocalStorage dla request isolation:**
```typescript
@Injectable()
export class UserContext {
  private readonly storage = new AsyncLocalStorage<UserContextStore>();

  setUserId(userId: string): void {
    this.storage.enterWith({ userId });
  }

  getCurrentUserId(): string {
    return this.storage.getStore()?.userId ?? throw Error();
  }
}
```

**Dlaczego to wzorcowe:**
- Thread-safe (Node.js async context)
- Nie trzeba przekazywaƒá userId przez wszystkie funkcje
- Clean code - implicit context, explicit gdzie potrzeba (`getCurrentUserId()`)

#### üü† HIGH - Event Sourcing / Outbox Pattern (MISSING)

**Problem:** Domain events sƒÖ emitowane przez `EventEmitter2` (in-memory), ale:

1. **Brak gwarancji dostarczenia** - je≈õli listener rzuci exception, event jest zgubiony
2. **Brak transakcyjno≈õci** - workspace mo≈ºe byƒá stworzony, ale email lookup nie (race condition)

**Obecna implementacja:**
```typescript
// workspace.service.ts
const workspace = await this.prisma.forUser(userId, async (tx) => {
  return tx.workspace.create({ ... });
});

// Emit outside transaction! ‚ùå
this.eventEmitter.emit('workspace.member.added', new WorkspaceMemberAddedEvent(...));
```

**Ryzyko:**
- DB commit succeeds ‚Üí app crashes ‚Üí event never emitted ‚Üí `TenantUserEmailLookup` nie zostanie zaktualizowany

**Jak naprawiƒá (Outbox Pattern):**
```typescript
// 1. Save event to DB in same transaction
await tx.domainEvent.create({
  data: {
    type: 'workspace.member.added',
    payload: { userId, workspaceId },
    status: 'PENDING'
  }
});

// 2. Background worker reads events and emits
setInterval(async () => {
  const events = await prisma.domainEvent.findMany({ where: { status: 'PENDING' } });
  for (const event of events) {
    await eventEmitter.emit(event.type, event.payload);
    await prisma.domainEvent.update({ where: { id: event.id }, data: { status: 'PROCESSED' } });
  }
}, 1000);
```

**Alternatywa (l≈ºejsza):** At least u≈ºywaj transaction-level events:
```typescript
return this.prisma.forUser(userId, async (tx) => {
  const workspace = await tx.workspace.create({ ... });
  await this.tenantLookup.addLookupEntry(user.email, workspace.id); // ‚úÖ In transaction
  return workspace;
});
```

Obecna implementacja (listener asynchroniczny) dzia≈Ça w 99% przypadk√≥w, ale nie jest fault-tolerant.

---

### 5. Enterprise Data Modeling

#### üü¢ LOW - TenantUserEmailLookup Model

**Model:** Email hash ‚Üí Workspace mapping dla multi-tenant auth resolution
**Wzorzec bran≈ºowy:** Tenant Resolver Pattern (Auth0, Okta u≈ºywajƒÖ podobnych mechanizm√≥w)
**Referencje:** Auth0 Organization resolver, Okta tenant discovery

**Struktura:**
```prisma
model TenantUserEmailLookup {
  id          String @id @default(uuid())
  emailHash   String  // SHA-256 hash
  workspaceId String
  workspace   Workspace @relation(...)

  @@unique([emailHash, workspaceId])
  @@index([emailHash])
}
```

**Ocena elastyczno≈õci:** ‚úÖ GOOD

**Dobre decyzje:**
- Email hashing (security - brak plain text emails w lookup table)
- Unique constraint na (emailHash, workspaceId) - prevent duplicates
- Index na emailHash - fast lookup
- Cascade delete - cleanup when workspace deleted

**Potencjalne rozszerzenia (przysz≈Ço≈õƒá):**
- Dodaƒá `role` lub `permissions` do lookup (pre-fetch podczas resolving)
- Dodaƒá `lastAccessedAt` dla analytics
- Dodaƒá `invitationStatus: 'PENDING' | 'ACCEPTED'` je≈õli chcemy invite flow

**Sprawdzone z enterprise patterns:**
- Auth0: u≈ºywa `organization_id` + `user_id` mapping
- Okta: tenant discovery przez email domain (`@company.com` ‚Üí `company.okta.com`)
- Salesforce: Party Data Model (Party ‚Üí Account mapping)

**R√≥≈ºnica:** Knowledge Forge u≈ºywa email hash (privacy), zamiast email domain (convenience). To trade-off:
- ‚úÖ Privacy: Leak lookup table ‚â† leak emails
- ‚ùå UX: Nie mo≈ºna auto-discover workspace po domenie (`@acme.com` ‚Üí Acme workspace)

**Rekomendacja:** Rozwa≈ºyƒá **hybrid approach**:
```prisma
model TenantUserEmailLookup {
  emailHash   String
  emailDomain String?  // Optional: 'acme.com' for auto-discovery
  workspaceId String

  @@unique([emailHash, workspaceId])
  @@index([emailHash])
  @@index([emailDomain]) // Auto-discover: user@acme.com ‚Üí find workspaces with emailDomain='acme.com'
}
```

Ale to **Won't Have** dla MVP - obecne rozwiƒÖzanie jest wystarczajƒÖce.

#### üü° MEDIUM - Workspace Model Flexibility

**Model:**
```prisma
model Workspace {
  id          String @id @default(uuid())
  name        String
  createdById String  // ‚Üê Dodane dla RLS INSERT policy

  createdBy   User @relation(fields: [createdById], references: [id])
  members     WorkspaceMember[]
}
```

**Pytania o elastyczno≈õƒá:**

1. **Czy Workspace mo≈ºe mieƒá wielu owners?**
   - Obecne: `createdById` sugeruje jednego ownera
   - Rzeczywisto≈õƒá: `WorkspaceMember.role = OWNER` mo≈ºe byƒá wielu
   - ‚úÖ OK - `createdById` to tylko "who pressed create button", nie business owner

2. **Czy nazwa workspace musi byƒá unikalna?**
   - Obecne: Brak unique constraint
   - ‚úÖ OK - u≈ºytkownik mo≈ºe mieƒá 2 workspace'y o tej samej nazwie

3. **Czy workspace mo≈ºe byƒá zarchiwizowany (soft delete)?**
   - Obecne: Brak `deletedAt`, `status` fields
   - üü° Potencjalny problem - hard delete mo≈ºe usunƒÖƒá dane klient√≥w bez recovery

**Sugestia (LOW priority):**
```prisma
model Workspace {
  id          String @id @default(uuid())
  name        String
  createdById String
  status      WorkspaceStatus @default(ACTIVE) // ACTIVE, ARCHIVED, SUSPENDED
  deletedAt   DateTime? @db.Timestamptz

  // Soft delete policies:
  // - ARCHIVED: read-only, can be restored
  // - SUSPENDED: no access (billing issue)
  // - Hard delete after 30 days of ARCHIVED
}

enum WorkspaceStatus {
  ACTIVE
  ARCHIVED
  SUSPENDED
}
```

**Dla MVP:** Obecny model jest wystarczajƒÖcy. Soft delete to enterprise feature.

#### üü¢ LOW - Member Relationship (OK for MVP)

**Model:**
```prisma
model WorkspaceMember {
  id          String @id @default(uuid())
  workspaceId String
  userId      String
  role        Role @default(MEMBER)

  workspace Workspace @relation(...)
  user      User @relation(...)

  @@unique([workspaceId, userId])
}
```

**Elastyczno≈õƒá:** ‚úÖ GOOD

- N:M relationship (user can be in many workspaces, workspace has many users)
- Role per membership (OWNER, ADMIN, MEMBER)
- Unique constraint - prevents duplicate memberships

**Potencjalne rozszerzenia:**
- `invitedAt`, `acceptedAt` dla invite flow
- `invitedBy` (userId) dla audit trail
- `permissions: Json` dla fine-grained RBAC (zamiast tylko role)

**Sprawdzone z enterprise:**
- Slack: Workspace ‚Üí User (similar, with channels on top)
- GitHub: Organization ‚Üí Member (OWNER, ADMIN, MEMBER)
- Google Workspace: Domain ‚Üí User (role-based)

**Verdict:** Obecny model jest zgodny z industry standards.

---

### 6. Security & RLS-specific Concerns

#### ‚úÖ EXCELLENT - Non-superuser Database Account

**Implementacja:**
```typescript
// .env
DATABASE_URL="postgresql://knowledge_forge_app:...@localhost:6201/knowledge_forge"
DATABASE_URL_MIGRATE="postgresql://postgres:...@localhost:6201/knowledge_forge"
```

**Dlaczego to kluczowe:**
- PostgreSQL superuser ALWAYS bypasses RLS (even with FORCE ROW LEVEL SECURITY)
- Production app musi u≈ºywaƒá non-superuser account
- Migracje u≈ºywajƒÖ superuser (DATABASE_URL_MIGRATE)

**Best practice alignment:** ‚úÖ
- Principle of least privilege
- Separation of admin vs runtime credentials

#### ‚úÖ EXCELLENT - SECURITY DEFINER dla helper function

**Implementacja:**
```sql
CREATE OR REPLACE FUNCTION get_user_workspace_ids()
RETURNS SETOF UUID AS $$
  ...
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
```

**Dlaczego SECURITY DEFINER:**
- Funkcja musi czytaƒá `WorkspaceMember` table, kt√≥ra ma RLS
- Chicken-and-egg: policy na WorkspaceMember u≈ºywa `get_user_workspace_ids()`, ale funkcja potrzebuje czytaƒá WorkspaceMember
- SECURITY DEFINER = uruchamia funkcjƒô z prawami ownera (bypasses RLS)

**Zagro≈ºenie:** SECURITY DEFINER mo≈ºe byƒá exploit vector (SQL injection).

**Mitigation w kodzie:**
```sql
user_id_uuid := user_id_text::UUID; -- ‚úÖ Type cast validates UUID format (no injection)
```

‚úÖ Bezpieczne - nie ma string concatenation, u≈ºywa parametr√≥w.

#### üü† HIGH - RlsBypassService ma b≈ÇƒôdnƒÖ implementacjƒô

**Obecna implementacja:**
```typescript
// rls-bypass.service.ts
async withBypass<T>(callback: (tx: TransactionClient) => Promise<T>) {
  return this.prisma.$transaction(async (tx) => {
    await tx.$executeRaw`SELECT set_config('app.current_user_id', '', true)`; // ‚ùå WRONG
    return callback(tx);
  });
}
```

**Problem:** Ustawienie `app.current_user_id = ''` (empty string) NIE jest tym samym co SYSTEM context.

**RLS policies sprawdzajƒÖ:**
```sql
-- get_user_workspace_ids() function:
IF user_id_text IS NULL OR user_id_text = '' THEN
  RETURN; -- Returns empty set!
END IF;
```

Wiƒôc `withBypass()` zwr√≥ci **ZERO wynik√≥w**, nie "wszystkie wyniki".

**Prawid≈Çowa implementacja (zgodna z PrismaService.withoutRls):**
```typescript
async withBypass<T>(callback: ...) {
  return this.prisma.$transaction(async (tx) => {
    await tx.$executeRaw`SELECT set_config('app.current_user_id', 'SYSTEM', true)`;
    // ‚úÖ SYSTEM context bypasses RLS (needs policy support)
    return callback(tx);
  });
}
```

**I policies muszƒÖ mieƒá:**
```sql
CREATE POLICY workspace_select ON "Workspace"
  FOR SELECT USING (
    get_current_user_id() = 'SYSTEM' OR -- ‚úÖ Bypass for SYSTEM
    id IN (SELECT * FROM get_user_workspace_ids())
  );
```

**Status:** `PrismaService.withoutRls()` u≈ºywa `'SYSTEM'` ‚úÖ, ale `RlsBypassService.withBypass()` u≈ºywa `''` ‚ùå.

**Rekomendacja:** Usu≈Ñ `RlsBypassService` (duplikat funkcjonalno≈õci) i u≈ºywaj tylko `PrismaService.withoutRls()`.

#### üî¥ CRITICAL - Public API nie ma bypass implementacji

**SPEC-001 m√≥wi:**
> "Public API - osobny mechanizm (token-based, bypass RLS)"

**Problem:** Nie znalaz≈Çem implementacji Public API controller u≈ºywajƒÖcego `withoutRls()` lub `withBypass()`.

**Oczekiwane:**
```typescript
// public.controller.ts
@Controller('public')
export class PublicController {
  async searchPublic(@Param('token') token: string, @Query('query') query: string) {
    // 1. Validate token (outside RLS)
    const publicLink = await this.prisma.withoutRls(async (tx) => {
      return tx.publicLink.findUnique({ where: { token } });
    });

    if (!publicLink) throw new UnauthorizedException();

    // 2. Search documents in workspace (bypass RLS)
    return this.prisma.withoutRls(async (tx) => {
      return tx.document.findMany({
        where: { workspaceId: publicLink.workspaceId }
      });
    });
  }
}
```

**Status:** `PublicLinkModule` prawdopodobnie istnieje, ale nie mogƒô zweryfikowaƒá u≈ºycia bypass bez przeczytania controller.

**Rekomendacja:** Code review `PublicController` - upewniƒá siƒô ≈ºe u≈ºywa `withoutRls()` dla wszystkich queries.

---

### 7. Testing & TDD Compliance

#### üî¥ CRITICAL - Brak plik√≥w testowych w repozytorium

**Specyfikacja SPEC-001 m√≥wi:**
> "Testy integracyjne izolacji (26/26 tests PASSING)"

**Rzeczywisto≈õƒá:**
```bash
find apps/api/test -type f -name "*.ts" 2>/dev/null
# Output: (empty)
```

**Problem:**
1. Brak test√≥w w repo (mo≈ºe sƒÖ lokalne?)
2. CLAUDE.md wymaga: "Zawsze pisz testy najpierw (TDD)"
3. Nie mogƒô zweryfikowaƒá quality implementacji bez test√≥w

**Unit testy:**
- `UserContext.spec.ts` - istnieje w `src/infrastructure/persistence/rls/` ‚úÖ
- `RlsMiddleware.spec.ts` - istnieje ‚úÖ
- `hash.util.spec.ts` - istnieje ‚úÖ

**E2E/Integration testy:**
- Brak w `apps/api/test/` ‚ùå
- Brak w `apps/api/src/**/*.e2e-spec.ts` ‚ùå

**Rekomendacja:**
1. Commit test files do repo (je≈õli istniejƒÖ lokalnie)
2. Je≈õli nie istniejƒÖ - napisz integration tests dla RLS:
   - User A nie widzi workspace B
   - User A nie mo≈ºe modyfikowaƒá document z workspace B
   - Public API bypasses RLS
   - Stress test (50+ concurrent users)

**Definition of Done m√≥wi:**
```markdown
- [x] Testy integracyjne izolacji (**26/26 tests PASSING**)
```

Je≈õli testy nie sƒÖ w repo, to **DoD nie jest spe≈Çnione** (can't verify).

---

## Zgodno≈õƒá z ADR

**Status:** Brak formalnych ADR w projekcie (tylko specyfikacje).

**Rekomendacja:** Stworzyƒá ADR dla kluczowych decyzji:
- **ADR-001:** Row Level Security as multi-tenancy strategy
- **ADR-002:** AsyncLocalStorage for request context
- **ADR-003:** Email hashing for tenant lookup (vs email domain)
- **ADR-004:** Non-superuser database account for production
- **ADR-005:** Direct column comparison for INSERT policies (not subquery)

ADRy pomogƒÖ onboardingowi nowych dev√≥w i dokumentujƒÖ "dlaczego" (nie tylko "co").

---

## Podsumowanie - Priority Matrix

### üî¥ CRITICAL (Napraw natychmiast)

1. **[DDD] Brak Workspace Aggregate** - logika biznesowa w service layer
   - **Impact:** Trudno≈õƒá utrzymania, s≈Çaba separacja concerns
   - **Effort:** Medium (refactor service ‚Üí entity)
   - **How:** Stw√≥rz `WorkspaceEntity` w domain layer, przenie≈õ logikƒô

2. **[Security] RlsBypassService.withBypass() b≈Çƒôdna implementacja**
   - **Impact:** Public API mo≈ºe nie dzia≈Çaƒá (zwraca zero wynik√≥w)
   - **Effort:** Low (fix empty string ‚Üí 'SYSTEM')
   - **How:** Zmie≈Ñ `''` na `'SYSTEM'` lub usu≈Ñ klasƒô (duplikat PrismaService.withoutRls)

3. **[Testing] Brak integration test√≥w w repo**
   - **Impact:** Nie mo≈ºna zweryfikowaƒá RLS dzia≈Ça poprawnie
   - **Effort:** Medium (write 26 test cases)
   - **How:** Commit test files lub napisz nowe (user isolation, ID manipulation, bypass)

### üü† HIGH (Napraw przed produkcjƒÖ)

4. **[DDD] WorkspaceService u≈ºywa PrismaService zamiast repository**
   - **Impact:** Naruszenie Clean Architecture, trudne testowanie
   - **Effort:** Low (inject repository zamiast prisma)
   - **How:** DI dla `WORKSPACE_REPOSITORY`, refactor service

5. **[Enterprise] Brak Outbox Pattern dla domain events**
   - **Impact:** Race condition - workspace created, ale email lookup nie (app crash)
   - **Effort:** Medium (implement outbox table + worker)
   - **How:** Save events to DB, background worker emits

6. **[Data] PrismaWorkspaceRepository omija RLS**
   - **Impact:** Repository mo≈ºe zwr√≥ciƒá dane z obcych workspace'√≥w (je≈õli u≈ºywany)
   - **Effort:** Low (wrap queries w forUser())
   - **How:** `return this.prisma.forUser(userId, tx => tx.workspace.findMany(...))`

### üü° MEDIUM (Nice to have)

7. **[Data Modeling] Soft delete dla Workspace**
   - **Impact:** Przypadkowe usuniƒôcie workspace = permanent data loss
   - **Effort:** Low (add status, deletedAt fields)
   - **How:** Add WorkspaceStatus enum, implement soft delete logic

8. **[UX] TenantLookup - hybrid email hash + domain**
   - **Impact:** Lepsza UX (auto-discover workspace po email domain)
   - **Effort:** Medium (add emailDomain column, update sync)
   - **How:** Extract domain from email, add to lookup table

### üü¢ LOW (Sugestie)

9. **[Docs] Stworzyƒá formalne ADRy**
   - **Impact:** Lepszy onboarding, documentation
   - **Effort:** Low (write ADR markdown files)
   - **How:** Template z docs/adr/, opisz ka≈ºdƒÖ decyzjƒô RLS

10. **[Code Quality] UsunƒÖƒá RlsBypassService (duplikat)**
    - **Impact:** DRY, mniej kodu do utrzymania
    - **Effort:** Trivial (delete class, use PrismaService.withoutRls)
    - **How:** Find all usages, replace, delete file

---

## Mocne strony implementacji ‚úÖ

1. **Enterprise-grade RLS implementation** - wzorcowa zgodno≈õƒá z PostgreSQL best practices
2. **AsyncLocalStorage for context** - czysty kod, thread-safe
3. **Non-superuser account** - security best practice
4. **Event-driven architecture** - decoupling TenantLookup od Workspace
5. **Email hashing** - privacy by design
6. **SECURITY DEFINER function** - prawid≈Çowe rozwiƒÖzanie chicken-and-egg
7. **Direct column comparison for INSERT** - key insight z core-platform zastosowany poprawnie
8. **Comprehensive documentation** - SPEC-001 bardzo szczeg√≥≈Çowa

---

## Recommended Next Steps

**Immediate (przed merge do main):**
1. Fix RlsBypassService (`''` ‚Üí `'SYSTEM'`)
2. Commit integration tests (lub napisz nowe je≈õli nie istniejƒÖ)
3. Fix PrismaWorkspaceRepository (u≈ºyj `forUser()`)

**Before production:**
4. Implement Outbox Pattern (lub inline event handlers w transaction)
5. Refactor WorkspaceService ‚Üí use repository (nie prisma bezpo≈õrednio)
6. Create WorkspaceEntity (domain layer)

**Post-MVP:**
7. Add soft delete dla Workspace
8. Create formal ADRs
9. Rozwa≈ºyƒá hybrid email hash + domain dla TenantLookup

---

## Final Verdict

**Og√≥lna ocena:** üü¢ **GOOD** (7/10)

**Uzasadnienie:**
- RLS implementation jest technicznie wzorcowa (migrations, policies, SECURITY DEFINER)
- Infrastructure layer jest dobrze zaprojektowana (UserContext, RlsMiddleware)
- Clean Architecture jest czƒô≈õciowo zachowana (dobre: domain entities; z≈Çe: service u≈ºywa prisma bezpo≈õrednio)
- DDD principles sƒÖ czƒô≈õciowo stosowane (dobre: DocumentEntity; z≈Çe: brak WorkspaceEntity)
- Security best practices sƒÖ stosowane (non-superuser, email hashing, FORCE RLS)

**G≈Ç√≥wne mankamenty:**
- Anemic Domain Model dla Workspace (logika w service, nie w entity)
- Brak repository usage w service (omijanie Clean Architecture)
- Brak fault-tolerant event handling (in-memory events bez outbox)
- Integration tests nie sƒÖ w repo (nie mo≈ºna zweryfikowaƒá)

**Recommended for merge:** ‚úÖ YES (po fixach CRITICAL)

**Production-ready:** üü° ALMOST (po fixach HIGH)

---

## Sources

Enterprise data modeling research:
- [A Universal Person and Organization Data Model](https://tdan.com/a-universal-person-and-organization-data-model/5014)
- [Party Data Models: A Comprehensive Guide 101](https://hevodata.com/learn/party-data-model/)
- [Good-Bye to the old CRM data model](https://liliendahl.com/2011/07/31/good-bye-to-the-old-crm-data-model/)
- [Oracle Party Data Model](https://docs.oracle.com/cd/E63029_01/books/Secur/secur_accesscontrol022.htm)
- [Salesforce Party Data Model](https://help.salesforce.com/s/articleView?id=sf.c360_a_party_data_model.htm&language=en_US&type=5)
- [Party Relationship Pattern - Vertabelo](https://vertabelo.com/blog/how-to-model-relationships/)
- [CRM Database Design - GeeksforGeeks](https://www.geeksforgeeks.org/dbms/how-to-design-a-relational-database-for-customer-relationship-management-crm/)
- [CRM Systems: Architecture Pattern, Data Modeling Strategies](https://dzone.com/articles/scalable-crm-architecture-and-data-modeling)

---

**Report generated:** 2025-12-25
**Reviewed by:** Architecture Reviewer Agent (Claude Sonnet 4.5)
**Specification:** SPEC-001-row-level-security.md
**Commit range:** Initial RLS implementation (9 migrations)
