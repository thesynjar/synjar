# Architecture Review Report - SPEC-011-frontend-auth.md

**Date:** 2025-12-25
**Spec:** SPEC-011: Frontend - Auth
**Status:** Draft
**Reviewer:** Architecture Reviewer Agent

---

## Kontekst

- **ModuÅ‚:** Frontend (apps/web)
- **Bounded Context:** Authentication Context
- **Przeczytane dokumenty:**
  - SPEC-011-frontend-auth.md (specyfikacja frontend auth)
  - CLAUDE.md (zasady inÅ¼ynieryjne Community)
  - community/TODO.md (lista zadaÅ„ i code review findings)
  - docs/specifications/2025-12-24-synjar-mvp.md (MVP spec)
  - docs/ARCHITECTURE_DECISION.md (standalone product decision)
  - docs/security/SECURITY_GUIDELINES.md (security requirements)
  - docs/agents/architecture-reviewer/reports/2025-12-24-14-00-initial-review.md (poprzedni raport)
- **PowiÄ…zane przepÅ‚ywy:**
  - Login flow: User credentials â†’ Backend /auth/login â†’ JWT w HTTP-only cookies â†’ Frontend AuthContext update
  - Register flow: User data â†’ Backend /auth/register â†’ JWT w HTTP-only cookies â†’ Auto-login
  - Session check: useEffect mount â†’ Backend /auth/me â†’ User state
  - Token refresh: 401 response â†’ Backend /auth/refresh â†’ Retry original request
  - Logout: User action â†’ Backend /auth/logout â†’ Clear cookies â†’ Redirect

---

## ğŸ”´ CRITICAL (Å‚amie fundamentalne zasady)

### [Security] Token Storage - NARUSZENIE Security Guidelines

**Problem:**
Specyfikacja mÃ³wi:

```typescript
// SPEC-011-frontend-auth.md:189-232
const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL || '/api/v1',
  withCredentials: true, // Send cookies
});

// Response interceptor for token refresh
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If 401 and not already retrying
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // Try to refresh token
        await axios.post(
          `${apiClient.defaults.baseURL}/auth/refresh`,
          {},
          { withCredentials: true }
        );

        // Retry original request
        return apiClient(originalRequest);
      } catch (refreshError) {
        // Refresh failed, redirect to login
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```

**Backend implementation (juÅ¼ zaimplementowane):**

```typescript
// apps/api/src/interfaces/http/auth.controller.ts:49-61
res.cookie('access_token', result.accessToken, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 15 * 60 * 1000, // 15 minutes
});

res.cookie('refresh_token', result.refreshToken, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
});
```

**Dlaczego to CRITICAL:**

1. **ZGODNE z Security Guidelines** - backend uÅ¼ywa HTTP-only cookies âœ…
2. **Frontend config jest prawidÅ‚owy** - `withCredentials: true` âœ…
3. **Ale SPEC nie dokumentuje `GET /auth/me` endpoint** âŒ

**Code Review Findings (TODO.md):**

```markdown
### CRITICAL (Before Production)

#### Security

- [x] **JWT token storage** - Access token w pamiÄ™ci, refresh w localStorage, API client z Authorization header
  - Files: `apps/web/src/features/auth/model/authStore.ts`, `apps/web/src/shared/api/client.ts`
```

**SPRZECZNOÅšÄ†:**
TODO.md mÃ³wi o **localStorage** (NIEBEZPIECZNE), ale SPEC-011 mÃ³wi o **HTTP-only cookies** (BEZPIECZNE).

**KtÃ³ra implementacja jest aktualnie w kodzie?**

Nie mogÄ™ tego sprawdziÄ‡ bez czytania `apps/web/src/features/auth/model/authStore.ts`, ale **jeÅ›li token jest w localStorage - to CRITICAL security issue**.

**Jak naprawiÄ‡ SPEC-011:**

1. **DodaÄ‡ endpoint `/auth/me`** do specyfikacji (backend juÅ¼ go ma):

```typescript
### 4.7 Auth Me Endpoint

```typescript
// Backend endpoint (already implemented)
@Get('me')
@UseGuards(JwtAuthGuard)
async getCurrentUser(@CurrentUser() user: JwtPayload) {
  return this.authService.getUserById(user.sub);
}
```

Frontend usage:

```typescript
// src/shared/lib/auth-context.tsx
const checkSession = async () => {
  try {
    const response = await apiClient.get('/auth/me'); // Uses cookies automatically
    setUser(response.data);
  } catch {
    setUser(null);
  } finally {
    setIsLoading(false);
  }
};
```

2. **UsunÄ…Ä‡ `RefreshTokenDto` z body** - refresh token jest w cookie:

```typescript
// SPEC-011-frontend-auth.md:79-85 - WRONG
@Post('refresh')
@ApiOperation({ summary: 'Refresh access token' })
@ApiResponse({ status: 200, description: 'Token refreshed successfully' })
@ApiResponse({ status: 401, description: 'Invalid refresh token' })
async refresh(
  @Body() dto: RefreshTokenDto, // âŒ Token should come from cookie
  @Res({ passthrough: true }) res: Response,
): Promise<{ message: string }> {
  const tokens = await this.authService.refreshTokens(dto.refresh_token);
  // ...
}
```

**PRAWIDÅOWO (zgodnie z backend):**

```typescript
@Post('refresh')
async refresh(
  @Req() req: Request, // Read refresh_token from cookies
  @Res({ passthrough: true }) res: Response,
): Promise<{ message: string }> {
  const refreshToken = req.cookies['refresh_token'];
  if (!refreshToken) {
    throw new UnauthorizedException('No refresh token');
  }
  const tokens = await this.authService.refreshTokens(refreshToken);
  // Set new cookies...
}
```

---

### [Architecture] Brak Backend API Specification - ZaÅ‚oÅ¼enie Å¼e API istnieje

**Problem:**
SPEC-011 zakÅ‚ada Å¼e backend API endpoints istniejÄ…:

```
POST /auth/register
POST /auth/login
POST /auth/refresh
POST /auth/logout
```

**Ale nie dokumentuje:**

- Request/Response schemas
- Validation rules
- Error codes
- `GET /auth/me` endpoint

**Dlaczego to problem:**

- Frontend spec bez backend spec = niepeÅ‚na implementacja
- Developer nie wie jakie bÅ‚Ä™dy obsÅ‚ugiwaÄ‡
- Brak contract testing miÄ™dzy frontend a backend

**Jak naprawiÄ‡:**

DodaÄ‡ sekcjÄ™ **Backend API Contract**:

```markdown
## 4. Backend API Contract

### 4.1 POST /auth/register

**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss123",
  "name": "John Doe"
}
```

**Response (201 Created):**
```json
{
  "message": "Registration successful",
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "name": "John Doe"
  }
}
```

**Errors:**
- `409 Conflict` - Email already registered
- `400 Bad Request` - Validation errors

**Cookies Set:**
- `access_token` (httpOnly, secure, sameSite: strict, 15min)
- `refresh_token` (httpOnly, secure, sameSite: strict, 7 days)

### 4.2 POST /auth/login

**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss123"
}
```

**Response (200 OK):**
```json
{
  "message": "Login successful",
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "name": "John Doe"
  }
}
```

**Errors:**
- `401 Unauthorized` - Invalid credentials

**Cookies Set:**
- `access_token` (httpOnly, secure, sameSite: strict, 15min)
- `refresh_token` (httpOnly, secure, sameSite: strict, 7 days)

### 4.3 GET /auth/me

**Request:**
- Requires `access_token` cookie

**Response (200 OK):**
```json
{
  "id": "uuid",
  "email": "user@example.com",
  "name": "John Doe"
}
```

**Errors:**
- `401 Unauthorized` - No valid access token

### 4.4 POST /auth/refresh

**Request:**
- Requires `refresh_token` cookie
- Body: empty

**Response (200 OK):**
```json
{
  "message": "Token refreshed successfully"
}
```

**Cookies Set:**
- `access_token` (new token)
- `refresh_token` (new token)

**Errors:**
- `401 Unauthorized` - Invalid/expired refresh token

### 4.5 POST /auth/logout

**Request:**
- No body required

**Response (200 OK):**
```json
{
  "message": "Logout successful"
}
```

**Cookies Cleared:**
- `access_token`
- `refresh_token`
```

---

### [DDD] Brak Bounded Context Definition

**Problem:**
Specyfikacja nie definiuje Bounded Context dla Authentication.

**Dlaczego to problem:**

- Frontend Authentication Context â‰  Backend Authentication Domain
- Nie wiadomo gdzie koÅ„czy siÄ™ odpowiedzialnoÅ›Ä‡ auth, a zaczyna workspace management
- Brak jasnych granic = coupling miÄ™dzy moduÅ‚ami

**Zgodnie z MVP spec (2025-12-24-synjar-mvp.md:109-142):**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SYNJAR COMMUNITY                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ WORKSPACE       â”‚  â”‚ CONTENT         â”‚                  â”‚
â”‚  â”‚ CONTEXT         â”‚  â”‚ CONTEXT         â”‚                  â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚                  â”‚
â”‚  â”‚ â€¢ Workspace     â”‚  â”‚ â€¢ Document      â”‚                  â”‚
â”‚  â”‚ â€¢ Member        â”‚  â”‚ â€¢ Chunk         â”‚                  â”‚
â”‚  â”‚                 â”‚  â”‚ â€¢ Tag           â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
```

**Brakuje Authentication Context!**

**Jak naprawiÄ‡:**

DodaÄ‡ sekcjÄ™ **Bounded Context**:

```markdown
## 2. Bounded Context: Authentication

### OdpowiedzialnoÅ›ci

**Authentication Context odpowiada za:**

1. User authentication (login, register)
2. Session management (JWT tokens w cookies)
3. Token refresh
4. Logout

**GRANICE:**

**NIE naleÅ¼y do Authentication Context:**
- Workspace management (to Workspace Context)
- User profile management (to User Context)
- Authorization/permissions (to Access Control Context)

**Integracja z innymi kontekstami:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRONTEND ARCHITECTURE                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ AUTH CONTEXT     â”‚       â”‚ WORKSPACE        â”‚            â”‚
â”‚  â”‚                  â”‚       â”‚ CONTEXT          â”‚            â”‚
â”‚  â”‚ â€¢ login()        â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚ â€¢ Requires auth  â”‚            â”‚
â”‚  â”‚ â€¢ register()     â”‚       â”‚ â€¢ Uses AuthCtx   â”‚            â”‚
â”‚  â”‚ â€¢ logout()       â”‚       â”‚   for user       â”‚            â”‚
â”‚  â”‚ â€¢ user           â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚  â”‚ â€¢ isAuth         â”‚                                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚           â”‚                 â”‚ DOCUMENT         â”‚            â”‚
â”‚           â”‚                 â”‚ CONTEXT          â”‚            â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ â€¢ Requires auth  â”‚            â”‚
â”‚                             â”‚ â€¢ Uses AuthCtx   â”‚            â”‚
â”‚                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Zasady:**

- Auth Context NIE importuje innych kontekstÃ³w
- Inne konteksty mogÄ… importowaÄ‡ Auth Context (read-only)
- Auth Context emituje zdarzenia (UserLoggedIn, UserLoggedOut) - inne konteksty mogÄ… subskrybowaÄ‡
```

---

## ğŸŸ  HIGH (powaÅ¼ne naruszenie)

### [DDD] Anemic AuthContext - logika biznesowa w komponencie

**Problem:**

```typescript
// SPEC-011-frontend-auth.md:112-186
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const queryClient = useQueryClient();

  // Check session on mount
  useEffect(() => {
    checkSession();
  }, []);

  const checkSession = async () => {
    try {
      const response = await apiClient.get('/auth/me');
      setUser(response.data);
    } catch {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    const response = await apiClient.post('/auth/login', { email, password });
    setUser(response.data.user);
    queryClient.clear(); // Clear cache on login
  };

  const register = async (data: RegisterData) => {
    const response = await apiClient.post('/auth/register', data);
    setUser(response.data.user);
  };

  const logout = async () => {
    await apiClient.post('/auth/logout');
    setUser(null);
    queryClient.clear();
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        isAuthenticated: !!user,
        login,
        register,
        logout,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}
```

**Dlaczego to problem:**

1. **Naruszenie Clean Architecture** - React Context miesza UI layer z application layer
2. **Brak warstwy Application** - logika API calls powinna byÄ‡ w use case / service
3. **Trudne testowanie** - nie moÅ¼na testowaÄ‡ logiki bez React
4. **Coupling do React Query** - `queryClient.clear()` w auth logic

**Zgodnie z CLAUDE.md:**

```
## 3. Layer Architecture

Domain Layer (business logic)
  - Aggregates, Value Objects, Domain Services
  - NO infrastructure dependencies
  â†“
Application Layer (orchestration)
  - Orchestrators, Use Cases (ACL translation)
  - Repository/Service interfaces
  â†“
Infrastructure Layer
  - Repository implementations, External API adapters
```

**Frontend powinien mieÄ‡ analogicznÄ… strukturÄ™!**

**Jak naprawiÄ‡:**

```typescript
// src/application/auth/auth.service.ts (Application Layer)
export class AuthService {
  constructor(private apiClient: ApiClient) {}

  async login(email: string, password: string): Promise<User> {
    const response = await this.apiClient.post('/auth/login', { email, password });
    return response.data.user;
  }

  async register(data: RegisterData): Promise<User> {
    const response = await this.apiClient.post('/auth/register', data);
    return response.data.user;
  }

  async checkSession(): Promise<User | null> {
    try {
      const response = await this.apiClient.get('/auth/me');
      return response.data;
    } catch {
      return null;
    }
  }

  async logout(): Promise<void> {
    await this.apiClient.post('/auth/logout');
  }
}

// src/features/auth/hooks/useAuth.ts (Presentation Layer)
export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const authService = useAuthService(); // DI przez context
  const queryClient = useQueryClient();

  useEffect(() => {
    authService.checkSession().then((user) => {
      setUser(user);
      setIsLoading(false);
    });
  }, []);

  const login = async (email: string, password: string) => {
    const user = await authService.login(email, password);
    setUser(user);
    queryClient.clear();
  };

  const logout = async () => {
    await authService.logout();
    setUser(null);
    queryClient.clear();
  };

  return { user, isLoading, isAuthenticated: !!user, login, logout };
}

// src/shared/lib/auth-context.tsx (Infrastructure - tylko provider)
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const auth = useAuth();
  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;
}
```

**Zalety:**

- Logika biznesowa testowalna bez React
- Separation of Concerns (UI â†” Business Logic)
- Åatwa podmiana implementacji API client
- ZgodnoÅ›Ä‡ z Clean Architecture

---

### [Security] Brak HTTPS Enforcement - Plain Text Credentials

**Problem:**
TODO.md wspomina:

```markdown
#### Security

- [ ] **HTTPS enforcement** - Credentials przesyÅ‚ane plain text, JWT moÅ¼e byÄ‡ przechwycony (MITM)
  - Config: nginx.conf, vite.config.ts (plugin-basic-ssl dla dev)
```

**SPEC-011 NIE wspomina o HTTPS wcale.**

**Dlaczego to HIGH:**

- Credentials (email, password) sÄ… przesyÅ‚ane plain text bez TLS
- JWT w cookies moÅ¼e byÄ‡ przechwycony przez MITM attack
- `secure: process.env.NODE_ENV === 'production'` zakÅ‚ada Å¼e production = HTTPS, ale nie wymusza

**Zgodnie z Security Guidelines:**

```markdown
### 5.2 .env Files

**MANDATORY:**

- .env MUST be in .gitignore
- Provide .env.example with placeholder values
- Document all env vars in README
```

**Jak naprawiÄ‡ SPEC-011:**

DodaÄ‡ sekcjÄ™ **Security Requirements**:

```markdown
## 8. Security Requirements

### 8.1 HTTPS Enforcement

**MANDATORY for production:**

- All API requests MUST use HTTPS
- Backend MUST enforce HTTPS (redirect HTTP â†’ HTTPS)
- Frontend MUST validate `secure` flag on cookies

**Development setup:**

```bash
# Install vite-plugin-basic-ssl
pnpm add -D @vitejs/plugin-basic-ssl

# vite.config.ts
import basicSsl from '@vitejs/plugin-basic-ssl';

export default defineConfig({
  plugins: [react(), basicSsl()],
  server: {
    https: true, // Enable HTTPS in dev
    port: 5173,
  },
});
```

**Backend verification:**

```typescript
// src/main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Enforce HTTPS in production
  if (process.env.NODE_ENV === 'production') {
    app.use((req, res, next) => {
      if (!req.secure && req.get('x-forwarded-proto') !== 'https') {
        return res.redirect(`https://${req.get('host')}${req.url}`);
      }
      next();
    });
  }

  await app.listen(6200);
}
```

### 8.2 Cookie Security

Backend sets cookies with flags:

- `httpOnly: true` - Prevents XSS attacks
- `secure: true` - Only sent over HTTPS
- `sameSite: 'strict'` - Prevents CSRF attacks

Frontend MUST:

- Use `withCredentials: true` in axios config âœ…
- Never access cookies via `document.cookie` âœ…
- Handle 401 errors gracefully âœ…

### 8.3 CORS Configuration

**Backend MUST whitelist frontend origin:**

```typescript
// apps/api/src/main.ts
app.enableCors({
  origin: [
    'http://localhost:5173', // dev
    'https://app.synjar.com', // production
  ],
  credentials: true,
});
```
```

---

### [Testing] Brak testÃ³w - naruszenie TDD z CLAUDE.md

**Problem:**
SPEC-011 definiuje testy, ale sÄ… to **unit tests z mockami**:

```typescript
// SPEC-011-frontend-auth.md:453-492
describe('LoginForm', () => {
  it('calls login on valid submit', async () => {
    const mockLogin = vi.fn();
    vi.mocked(useAuth).mockReturnValue({ login: mockLogin, ... });

    render(<LoginForm />);

    await userEvent.type(screen.getByLabelText(/email/i), 'test@example.com');
    await userEvent.type(screen.getByLabelText(/password/i), 'password123');
    await userEvent.click(screen.getByRole('button', { name: /sign in/i }));

    expect(mockLogin).toHaveBeenCalledWith('test@example.com', 'password123');
  });
});
```

**Dlaczego to problem:**

1. **Mockowanie useAuth = testowanie implementacji, nie zachowania**
2. **CLAUDE.md mÃ³wi:** "Testuj zachowanie, nie implementacjÄ™; preferuj szybkie unit/integration z realnymi adapterami (mockuj tylko zewnÄ™trzne API)."
3. **TODO.md mÃ³wi:** "[ ] **Zero testÃ³w** - Naruszenie TDD z CLAUDE.md. Dodaj vitest.config.ts + testy dla Login, Dashboard, Layout"

**Zgodnie z CLAUDE.md DDD testing strategy:**

```markdown
### 6. Testing Strategy

**Integration Tests > Unit Tests:**

- NEVER mock aggregates (contain business logic)
- Mock only external APIs (Stripe SDK)
- Use real API fixtures (JSON files)
- Verify end-to-end state changes
```

**Jak naprawiÄ‡:**

```typescript
// apps/web/src/features/auth/LoginForm.integration.test.tsx

describe('LoginForm (Integration)', () => {
  let apiMock: MockAdapter;

  beforeEach(() => {
    apiMock = new MockAdapter(axios); // Mock axios, nie useAuth
  });

  it('logs in user and navigates to dashboard', async () => {
    // Arrange: Mock backend response
    apiMock.onPost('/auth/login').reply(200, {
      message: 'Login successful',
      user: {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
      },
    });

    const navigate = vi.fn();
    vi.mocked(useNavigate).mockReturnValue(navigate);

    // Act: Render with real AuthProvider
    render(
      <AuthProvider>
        <LoginForm />
      </AuthProvider>
    );

    await userEvent.type(screen.getByLabelText(/email/i), 'test@example.com');
    await userEvent.type(screen.getByLabelText(/password/i), 'password123');
    await userEvent.click(screen.getByRole('button', { name: /sign in/i }));

    // Assert: Verify full flow
    await waitFor(() => {
      expect(navigate).toHaveBeenCalledWith('/');
      expect(apiMock.history.post.length).toBe(1);
      expect(apiMock.history.post[0].data).toEqual(
        JSON.stringify({ email: 'test@example.com', password: 'password123' })
      );
    });
  });

  it('shows error on invalid credentials', async () => {
    // Arrange: Mock backend error
    apiMock.onPost('/auth/login').reply(401, {
      message: 'Invalid credentials',
    });

    // Act
    render(
      <AuthProvider>
        <LoginForm />
      </AuthProvider>
    );

    await userEvent.type(screen.getByLabelText(/email/i), 'test@example.com');
    await userEvent.type(screen.getByLabelText(/password/i), 'wrong');
    await userEvent.click(screen.getByRole('button', { name: /sign in/i }));

    // Assert
    await waitFor(() => {
      expect(screen.getByText(/invalid email or password/i)).toBeInTheDocument();
    });
  });
});

// apps/web/src/application/auth/auth.service.test.ts (Unit test dla service)

describe('AuthService', () => {
  let service: AuthService;
  let apiClient: jest.Mocked<ApiClient>;

  beforeEach(() => {
    apiClient = {
      post: jest.fn(),
      get: jest.fn(),
    } as any;

    service = new AuthService(apiClient);
  });

  describe('login', () => {
    it('returns user on successful login', async () => {
      // Arrange
      apiClient.post.mockResolvedValue({
        data: { user: { id: '1', email: 'test@example.com' } },
      });

      // Act
      const user = await service.login('test@example.com', 'password123');

      // Assert
      expect(user).toEqual({ id: '1', email: 'test@example.com' });
      expect(apiClient.post).toHaveBeenCalledWith('/auth/login', {
        email: 'test@example.com',
        password: 'password123',
      });
    });

    it('throws on invalid credentials', async () => {
      // Arrange
      apiClient.post.mockRejectedValue({ response: { status: 401 } });

      // Act & Assert
      await expect(
        service.login('test@example.com', 'wrong')
      ).rejects.toThrow();
    });
  });
});
```

**Dlaczego lepsze:**

- Testuje zachowanie (user moÅ¼e siÄ™ zalogowaÄ‡), nie implementacjÄ™ (useAuth wywoÅ‚any)
- UÅ¼ywa realnego AuthProvider
- Mockuje tylko external API (axios)
- Zgodne z CLAUDE.md DDD testing strategy

---

## ğŸŸ¡ MEDIUM (do poprawy)

### [SOLID - SRP] AuthContext narusza Single Responsibility Principle

**Problem:**
AuthContext ma wiele odpowiedzialnoÅ›ci:

1. Authentication state management (user, isLoading)
2. API calls (login, register, logout)
3. Query cache management (`queryClient.clear()`)
4. Session validation (checkSession)

**Jak naprawiÄ‡:**

PodzieliÄ‡ na:

```typescript
// src/features/auth/model/auth.store.ts (State)
export function useAuthStore() {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  return { user, setUser, isLoading, setIsLoading };
}

// src/application/auth/auth.service.ts (Business Logic)
export class AuthService {
  async login(email: string, password: string): Promise<User> { ... }
  async register(data: RegisterData): Promise<User> { ... }
  async checkSession(): Promise<User | null> { ... }
  async logout(): Promise<void> { ... }
}

// src/features/auth/hooks/useAuth.ts (Orchestration)
export function useAuth() {
  const store = useAuthStore();
  const service = useAuthService();
  const queryClient = useQueryClient();

  const login = async (email: string, password: string) => {
    const user = await service.login(email, password);
    store.setUser(user);
    queryClient.clear();
  };

  // ...

  return { ...store, login, register, logout };
}
```

---

### [Clean Code] Magic strings - hardcoded URLs

**Problem:**

```typescript
// SPEC-011-frontend-auth.md:136-144
const checkSession = async () => {
  try {
    const response = await apiClient.get('/auth/me');
    setUser(response.data);
  } catch {
    setUser(null);
  } finally {
    setIsLoading(false);
  }
};
```

**Endpoint URLs hardcoded w wielu miejscach:**

- `/auth/login`
- `/auth/register`
- `/auth/me`
- `/auth/logout`
- `/auth/refresh`

**Jak naprawiÄ‡:**

```typescript
// src/config/api.routes.ts
export const API_ROUTES = {
  auth: {
    login: '/auth/login',
    register: '/auth/register',
    me: '/auth/me',
    logout: '/auth/logout',
    refresh: '/auth/refresh',
  },
  workspaces: {
    list: '/workspaces',
    byId: (id: string) => `/workspaces/${id}`,
    members: (id: string) => `/workspaces/${id}/members`,
  },
} as const;

// Usage:
const response = await apiClient.get(API_ROUTES.auth.me);
```

**Zalety:**

- Single source of truth
- Åatwa refaktoryzacja
- Type safety
- Autocomplete

---

### [UX] Brak email verification flow

**Problem:**
SPEC-011 implementuje rejestracjÄ™, ale **nie wspomina o email verification**.

**Zgodnie z best practices:**

- User rejestruje siÄ™ â†’ otrzymuje email z linkiem weryfikacyjnym
- Bez weryfikacji â†’ konto disabled
- Po klikniÄ™ciu link â†’ konto active

**Backend powinien mieÄ‡:**

```typescript
POST /auth/verify-email?token=xxx
```

**Frontend powinien mieÄ‡:**

```typescript
// src/features/auth/pages/VerifyEmailPage.tsx
export function VerifyEmailPage() {
  const [searchParams] = useSearchParams();
  const token = searchParams.get('token');

  useEffect(() => {
    if (token) {
      verifyEmail(token);
    }
  }, [token]);

  // ...
}
```

**Jak naprawiÄ‡ SPEC-011:**

DodaÄ‡ sekcjÄ™ **Email Verification (v2)**:

```markdown
### 2.2 FunkcjonalnoÅ›ci (v2)

4. **Email Verification**
   - User registers â†’ email sent
   - User clicks link â†’ account activated
   - VerifyEmailPage shows status
```

---

### [UX] Brak workspace creation podczas rejestracji

**Problem:**
MVP spec mÃ³wi:

```markdown
### UC1: Zapisanie zweryfikowanego ÅºrÃ³dÅ‚a

**Flow:**
1. User wybiera workspace
```

Ale SPEC-011 NIE tworzy workspace podczas rejestracji.

**Zgodnie z TODO.md:**

```markdown
- [x] **Dashboard** - [SPEC-012](docs/specifications/SPEC-012-frontend-dashboard.md)
  - Workspace list, navigation
  - **Status:** Basic UI done, needs error handling + tests
  - **Requires:** Auth
  - **Blocks:** Documents
```

**Dashboard wymaga workspace, ale auth nie tworzy workspace.**

**Jak naprawiÄ‡:**

DodaÄ‡ do **Register Flow**:

```markdown
### Register Flow (Enhanced)

1. User wpisuje email, password, name
2. Backend tworzy User
3. **Backend automatycznie tworzy pierwszy Workspace** ("My Workspace")
4. **Backend dodaje User jako OWNER do workspace**
5. Response zawiera user + workspace:

```json
{
  "message": "Registration successful",
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "name": "John Doe"
  },
  "workspace": {
    "id": "workspace-uuid",
    "name": "My Workspace"
  }
}
```

6. Frontend redirects to `/workspaces/{workspace-id}/documents`
```

---

### [Documentation] Brak ADR dla stack choices

**Problem:**
TODO.md mÃ³wi:

```markdown
- [ ] **ADR dla stack** - UdokumentowaÄ‡ wybÃ³r React 19, Vite 6, Tailwind 4
```

**SPEC-011 uÅ¼ywa:**

- React 18
- Vite (no version)
- React Router 6
- TanStack Query
- Tailwind CSS
- React Hook Form
- Zod

**Ale nie ma ADR dokumentujÄ…cego WHY te wybory.**

**Jak naprawiÄ‡:**

UtworzyÄ‡ `docs/adr/ADR-2025-12-25-frontend-stack.md`:

```markdown
# ADR-2025-12-25: Frontend Stack Selection

## Status
Accepted

## Context
We need to choose frontend stack for Synjar Community web application.

## Decision

### Framework: React 18
- **Why:** Mature, large ecosystem, team expertise
- **Alternatives:** Vue 3, Svelte, Solid.js
- **Trade-off:** Bundle size vs ecosystem

### Build Tool: Vite 6
- **Why:** Fast HMR, native ESM, TypeScript support
- **Alternatives:** Webpack, Parcel, esbuild
- **Trade-off:** Cutting edge vs stability

### Routing: React Router 6
- **Why:** Standard for React, nested routes, loaders
- **Alternatives:** TanStack Router, Wouter
- **Trade-off:** Bundle size vs features

### State Management: TanStack Query + Context API
- **Why:** Server state (TanStack Query), UI state (Context)
- **Alternatives:** Redux Toolkit, Zustand, Jotai
- **Trade-off:** Simplicity vs boilerplate

### Styling: Tailwind CSS 4
- **Why:** Utility-first, fast development, small bundle
- **Alternatives:** CSS Modules, Styled Components, Emotion
- **Trade-off:** HTML readability vs maintainability

### Forms: React Hook Form + Zod
- **Why:** Performance (uncontrolled), validation (Zod schema)
- **Alternatives:** Formik, React Final Form
- **Trade-off:** Learning curve vs bundle size

### HTTP Client: Axios
- **Why:** Interceptors, request/response transforms, cancellation
- **Alternatives:** fetch, ky, wretch
- **Trade-off:** Bundle size (13kb) vs DX

## Consequences

**Positive:**
- Modern, performant stack
- Good DX (developer experience)
- Type safety (TypeScript + Zod)

**Negative:**
- Tailwind HTML verbosity
- TanStack Query learning curve
- Axios bundle size
```

---

## ğŸŸ¢ LOW (sugestia)

### [UX] Brak "Forgot Password" flow

**Problem:**
SPEC-011 wspomina "Forgot Password" jako **v2**:

```markdown
### 2.1 Strony

| Strona | URL | DostÄ™p |
|--------|-----|--------|
| Login | /login | Public |
| Register | /register | Public |
| Forgot Password | /forgot-password | Public (v2) |
```

**Sugestia:**
DodaÄ‡ placeholder page w v1:

```typescript
// src/features/auth/pages/ForgotPasswordPage.tsx
export function ForgotPasswordPage() {
  return (
    <AuthLayout>
      <div className="text-center">
        <h2>Forgot Password</h2>
        <p>This feature will be available soon.</p>
        <p>
          Please contact support at{' '}
          <a href="mailto:support@synjar.com">support@synjar.com</a>
        </p>
      </div>
    </AuthLayout>
  );
}
```

**Dlaczego:**

- Lepsze UX niÅ¼ 404
- UÅ¼ytkownik wie Å¼e feature jest planowany
- Link z login page nie prowadzi donikÄ…d

---

### [Accessibility] Brak ARIA labels

**Problem:**
TODO.md mÃ³wi:

```markdown
- [ ] **Brak ARIA labels** - Formularze i przyciski bez labels (WCAG 2.1 Level A failure)
  - Files: `apps/web/src/features/auth/Login.tsx`, `apps/web/src/features/dashboard/Dashboard.tsx`
```

**SPEC-011 nie wspomina o accessibility.**

**Jak naprawiÄ‡:**

DodaÄ‡ sekcjÄ™ **Accessibility Requirements**:

```markdown
## 9. Accessibility (WCAG 2.1 Level AA)

### 9.1 Form Labels

All inputs MUST have associated labels:

```tsx
<label htmlFor="email" className="block text-sm font-medium">
  Email
</label>
<input
  id="email"
  type="email"
  aria-required="true"
  aria-invalid={!!errors.email}
  aria-describedby={errors.email ? 'email-error' : undefined}
  {...register('email')}
/>
{errors.email && (
  <p id="email-error" role="alert" className="text-red-600 text-sm">
    {errors.email.message}
  </p>
)}
```

### 9.2 Focus Management

- All interactive elements MUST have visible focus indicator
- Custom focus ring: `focus:ring-2 focus:ring-primary-500 focus:ring-offset-2`

### 9.3 Keyboard Navigation

- Forms MUST be fully navigable by keyboard (Tab, Shift+Tab, Enter)
- Buttons MUST trigger on Enter and Space

### 9.4 Screen Reader Support

- Loading states MUST announce: `<p role="status" aria-live="polite">Loading...</p>`
- Errors MUST announce: `<p role="alert">Invalid credentials</p>`
```

---

### [Performance] Brak code splitting

**Problem:**
SPEC-011 nie wspomina o code splitting / lazy loading.

**Sugestia:**

```typescript
// src/routes.tsx
import { lazy, Suspense } from 'react';

const LoginPage = lazy(() => import('@/features/auth/pages/LoginPage'));
const RegisterPage = lazy(() => import('@/features/auth/pages/RegisterPage'));
const DashboardPage = lazy(() => import('@/features/dashboard/pages/DashboardPage'));

export const router = createBrowserRouter([
  {
    element: <AuthLayout />,
    children: [
      {
        path: '/login',
        element: (
          <Suspense fallback={<LoadingSpinner />}>
            <LoginPage />
          </Suspense>
        ),
      },
      // ...
    ],
  },
]);
```

**Zalety:**

- Smaller initial bundle
- Faster TTI (Time To Interactive)
- Better Core Web Vitals

---

## âœ… Dobre praktyki

### HTTP-only Cookies dla JWT

SPEC-011 prawidÅ‚owo uÅ¼ywa HTTP-only cookies zgodnie z Security Guidelines:

```typescript
// Backend sets HTTP-only cookies
res.cookie('access_token', result.accessToken, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 15 * 60 * 1000,
});
```

**Zalety:**

- XSS protection (JavaScript nie moÅ¼e odczytaÄ‡ tokenu)
- CSRF protection (`sameSite: 'strict'`)
- Automatic cookie sending (`withCredentials: true`)

---

### Auto-refresh mechanism

Interceptor w apiClient automatycznie odÅ›wieÅ¼a token:

```typescript
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      await axios.post('/auth/refresh', {}, { withCredentials: true });
      return apiClient(originalRequest);
    }
    return Promise.reject(error);
  }
);
```

**Zalety:**

- Transparent dla uÅ¼ytkownika
- Seamless UX (user nie widzi bÅ‚Ä™dÃ³w)
- Zgodne z best practices (refresh token rotation)

---

### Type safety z Zod

Validacja formularzy przez Zod schemas:

```typescript
const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

type LoginFormData = z.infer<typeof loginSchema>;
```

**Zalety:**

- Runtime validation + compile-time types
- DRY (schema = types)
- Czytelne error messages

---

### Protected Route pattern

PrawidÅ‚owa implementacja protected routes:

```typescript
export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
}
```

**Zalety:**

- Loading state handling
- Redirect z zachowaniem previous location
- `replace` prevents back button issues

---

## ğŸ“‹ ZgodnoÅ›Ä‡ z ADR

| ADR Decision | Status | Uwagi |
|--------------|--------|-------|
| Synjar jako standalone product | âœ… Zgodne | Frontend jest osobny od enterprise |
| NestJS backend API | âœ… Zgodne | SPEC zakÅ‚ada API endpoints |
| JWT authentication | âœ… Zgodne | HTTP-only cookies |
| Multi-tenancy (workspace) | âš ï¸ CzÄ™Å›ciowo | Auth nie tworzy workspace |
| Clean Architecture layers | âŒ Niezgodne | AuthContext miesza UI + Application + Infrastructure |
| Security Guidelines (HTTPS, cookies) | âš ï¸ CzÄ™Å›ciowo | Cookies âœ…, HTTPS nie udokumentowane |
| TDD testing strategy | âŒ Niezgodne | Mockuje useAuth zamiast external API |

---

## Podsumowanie

### Priorytety do naprawy (przed implementacjÄ…):

1. **CRITICAL:** DodaÄ‡ Backend API Contract (endpoints, schemas, errors)
2. **CRITICAL:** UdokumentowaÄ‡ `/auth/me` endpoint
3. **CRITICAL:** SprawdziÄ‡ czy token JE W localStorage (jeÅ›li tak - NATYCHMIAST przenieÅ›Ä‡ do cookies)
4. **HIGH:** DodaÄ‡ Bounded Context definition
5. **HIGH:** Refactor AuthContext â†’ AuthService (Application Layer)
6. **HIGH:** DodaÄ‡ HTTPS enforcement documentation
7. **HIGH:** ZmieniÄ‡ testy na integration tests (mock axios, nie useAuth)
8. **MEDIUM:** DodaÄ‡ workspace creation podczas rejestracji
9. **MEDIUM:** DodaÄ‡ email verification flow (v2)
10. **MEDIUM:** UtworzyÄ‡ ADR dla frontend stack

### Silne strony:

- HTTP-only cookies dla JWT âœ…
- Auto-refresh mechanism âœ…
- Type safety (Zod + TypeScript) âœ…
- Protected routes pattern âœ…
- React Hook Form (performance) âœ…

### SÅ‚abe strony:

- Brak Backend API specification
- Brak Bounded Context definition
- AuthContext miesza UI + Business Logic (naruszenie Clean Architecture)
- Testy mockujÄ… useAuth zamiast API (naruszenie TDD z CLAUDE.md)
- Brak dokumentacji HTTPS enforcement
- Brak workspace creation flow

### Ocena ogÃ³lna:

**65/100** - Dobra podstawa, ale wymaga uzupeÅ‚nienia o:

1. Backend API Contract
2. Clean Architecture layers (AuthService)
3. Integration tests
4. Security documentation (HTTPS)
5. Bounded Context definition

**GÅ‚Ã³wne problemy:**

- Anemic frontend architecture (logika w UI layer)
- Brak peÅ‚nej specyfikacji (backend endpoints)
- Testowanie implementacji zamiast zachowania

**Rekomendacja:**

SPEC-011 jest dobry jako **UI/UX spec**, ale wymaga uzupeÅ‚nienia o:

- **Backend API spec** (dodaÄ‡ jako zaÅ‚Ä…cznik lub osobny plik)
- **Architecture Decision** (Clean Architecture layers dla frontend)
- **Security Requirements** (HTTPS, CORS, CSP)
- **Testing Strategy** (integration tests, nie unit mocks)

---

## Pliki do przeczytania przy nastÄ™pnym review:

- âœ… SPEC-011-frontend-auth.md
- âœ… CLAUDE.md (Community)
- âœ… community/TODO.md
- âœ… docs/specifications/2025-12-24-synjar-mvp.md
- âœ… docs/ARCHITECTURE_DECISION.md
- âœ… docs/security/SECURITY_GUIDELINES.md
- âœ… docs/agents/architecture-reviewer/reports/2025-12-24-14-00-initial-review.md
- â­ï¸ apps/web/src/features/auth/model/authStore.ts (jeÅ›li istnieje - weryfikacja localStorage)
- â­ï¸ apps/api/src/interfaces/dto/auth.dto.ts (weryfikacja backend contract)
- â­ï¸ SPEC-012-frontend-dashboard.md (workspace management)
